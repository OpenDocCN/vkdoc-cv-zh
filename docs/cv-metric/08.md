第八章

![image](images/frontdot.jpg)

视觉管道和优化

*“欲速则不达。。. "*

*—树须，*指环王

本章探讨了一些假设的计算机视觉流水线设计，以理解硬件/软件设计方案和优化。本章不是着眼于孤立的计算机视觉算法，而是将许多概念结合成完整的视觉管道。为了说明不同方法的使用，我们为几个示例应用程序勾勒出了视觉管道。示例应用包括使用汽车的形状和颜色的对象识别、使用局部特征的面部检测和情感检测、使用全局特征的图像分类以及增强现实。选择这些例子是为了说明在[第 5 章](05.html)中介绍的*视觉度量分类*中不同系列特征描述度量的使用。探索了视觉管道每个阶段的替代优化。例如，我们考虑哪些视觉算法在 CPU 上运行得比在 GPU 上运行得更好，并讨论计算单元和内存之间的数据传输时间如何影响性能。

![image](images/sq.jpg) **注**本章中的假设例子有时是粗略的，并不打算是完整的。相反，目的是探索设计的替代方案。示例*中的设计选择仅用于说明；*其他同样有效的设计选择可以用来构建工作系统。鼓励读者分析这些例子，找出弱点和替代方案。如果读者能改进这些例子，我们就成功了。

本章按顺序讨论了以下主要主题:

1.  针对整个 SOC (CPU、GPU、内存)优化的一般设计概念。
2.  使用不同描述符方法的四种假想视觉管道设计。
3.  软件优化资源和特定优化技术概述。

阶段、操作和资源

如图[图 8-1](#Fig1) 所示，计算机视觉解决方案可以在*阶段、*的流水线中实施。在流水线中，并行操作和顺序操作同时发生。通过以最佳方式使用所有可用的计算资源，可以最大限度地提高速度、功耗和内存效率。

![9781430259299_Fig08-01.jpg](images/9781430259299_Fig08-01.jpg)

[图 8-1](#_Fig1) 。虚拟分配将视觉管道阶段分配给运营和计算资源。根据实际的资源能力以及功耗和性能的优化目标，分配会有所不同

优化方法因系统而异。例如，用于移动电话的低功率系统可能不具有丰富的 CPU SIMD 指令集，并且 GPU 可能具有非常有限的线程计数和低存储器带宽，不适合用于视觉流水线的通用 GPGPU 处理。然而，较大计算设备，例如安装在机架上的计算服务器，可能具有几个 CPU 和 GPU，且每个 CPU 和 GPU 将具有强大的 SIMD 指令和高存储器带宽。

表 8-1 提供了基于数据类型和处理器能力的资源操作分配的更多细节。例如，在传感器处理阶段，点线和区域操作在工作负载中占主导地位，因为传感器数据被组合成像素并进行校正。大多数传感器处理器基于具有宽 SIMD 指令字的数字信号处理器(DSP) ，并且 DSP 还可以包含固定功能几何校正单元或翘曲单元，用于校正诸如透镜失真之类的光学问题。在[表 8-1](#Fig2) 中列出的传感器 DSP 和 GPU 通常包含一个专用的纹理采样器单元，能够进行快速像素插值、几何扭曲、仿射和透视变换。如果代码是有很多分支的直线，没有太多的并行操作，CPU 是最好的选择。

[表 8-1](#_Tab1) 。由数据类型和并行性指导的对计算资源的基本操作的假设分配(另见 Zinner [495])

![image](images/9781430259299_Table08-01.jpg)

如[表 8-1](#Tab1) 所示，数据类型和数据布局通常指导为给定任务选择最佳计算资源，以及算法和数据中的并行类型。此外，编程语言是基于并行性来选择的，例如使用 OpenCL 还是 C++。例如，CPU 可能支持浮点和双精度数据类型，但如果底层代码面向 SIMT 和 SIMD 并行，需要许多并发线程并行内核操作，那么具有高线程数的 GPU 可能是比单个 CPU 更好的选择。然而，在多个 CPU 上运行 OpenCL 这样的语言可能会提供与较小的 GPU 一样好的性能；有关性能信息，请参阅参考文献[544]以及 OpenCL 编译器的供应商信息。参见本章后面的“SIMD、SIMT 和 SPMD 基本面”一节

有关如何跨不同计算单元和内存优化基本图像处理操作的精彩讨论，请参见 Zinner 等人的 PfeLib 工作[495]，该工作深入探讨了基于数据类型和智能内存使用的优化类型。

为了使从视觉处理阶段到操作和计算资源的分配具体化，我们将在本章的后面查看具体的视觉管道示例。

计算资源预算

在实施愿景管道之前，应合理尝试计算可用计算平台资源的成本，并确定应用程序是否与资源匹配。例如，用于军事战场的系统可能会优先考虑计算速度和准确性，而用于移动设备的应用程序会优先考虑电池寿命，并在性能和准确性之间进行权衡。

由于大多数计算机视觉研究关注的是在处理相对狭窄和明确定义的问题方面的突破，因此可用于指导视觉管道分析和优化的一般工程讨论的研究有限。相反，我们遵循从硬件资源本身开始的思路，讨论性能、功耗、内存和 I/O 要求，并参考一些并行编程和其他代码优化方法的文献。视觉流水线分析和优化工程师将欢迎对自动化工具的进一步研究，以测量算法强度，如整数和浮点运算的数量、数据类型的位精度以及每个算法在读/写方面的内存传输数量。

如图[图 8-2](#Fig2) 所示，计算机系统的主要元素由 I/O、计算和内存组成。

![9781430259299_Fig08-02.jpg](images/9781430259299_Fig08-02.jpg)

[图 8-2](#_Fig2) 。假设的计算机系统，突出了 DSP、GPU、四个 CPU 内核、DMA 和内存架构形式的计算元素，在每个计算单元中使用 L1 和 L2 缓存和寄存器文件 RF

我们假设合适的高带宽 I/O 总线和高速缓存线将各种计算单元互连到存储器；在这种情况下，我们特别调用 MIPI 相机接口，它直接连接到我们假设的 SOC 中的 DSP。对于不久的将来的简单计算机视觉系统，我们假设价格、性能和功率曲线继续朝着正确的方向发展，以使大多数计算机视觉应用能够以低价格构建*片上系统* (SOC) ，接近一次性计算成本——与任何小型便携式电子设备的价格相似。因此，这将实现低功耗和高性能的无处不在的视觉应用，而无需求助于为任何特定的计算机视觉算法而构建的专用硬件加速器。

以下是对图 8-2 中[所示 SOC 组件](#Fig2)的概述:

*   两个 1080p 相机，一个用于 RGB，另一个用于独立的深度相机，如 TOF 传感器(如[第 1 章](01.html)中所述)。
*   **一个小型低功耗控制器 CPU** ，具有精简指令集且无浮点，用于处理简单的事情，如键盘、加速度计更新、服务来自 DSP 的中断以及其他周期性任务，如网络中断处理程序。
*   **三个具有浮点运算能力的全 SIMD CPU**，用于繁重的计算，通常是线程并行算法，如 tiling，但也用于 SIMD 并行算法。
*   **一个能够运行![image](images/arrow.jpg) 256 个全整数浮点线程的 GPU** ，四个纹理采样器。各种各样的区域算法都可以很好地映射到 GPU，但编程模型是 SIMT 内核，如 DirectX 和 OpenGL 或 OpenCL 的计算着色器。
*   **DSP**具有有限的指令集和 VLIW 处理能力，通常非常适合像素处理和传感器处理。
*   用于快速存储器传输的 DMA 单元；虽然显而易见，但 DMA 是一种简单有效的增加内存带宽和降低功耗的方法。

计算单元、算术逻辑单元和加速器

典型系统中有几种类型的计算单元，包括 CPU、GPU、DSP 和专用硬件加速器，如加密单元、纹理采样器和 DMA 引擎。每个 ALU 都有一个不同的指令集来适应预期的用途，因此了解每个计算单元的 ALU 指令集非常有帮助。

一般来说，计算机体系结构还没有发展到提供任何标准视觉流水线方法或硬件加速器的地步。这是因为计算机视觉出现了如此多的算法改进；选择在芯片中实现任何视觉加速器都有过时的风险。此外，创建计算机视觉硬件加速器也很困难，因为应用程序必须是可移植的。因此，开发人员通常选择足够好且可移植的高级语言实现，对专用硬件或 API 的依赖性最小。

相反，依赖 C++等通用语言并优化软件是一个很好的开始，正如根据需要利用 GPU 中现有的像素处理加速方法一样，如像素着色器和纹理采样器。标准 C++语言路径提供了跨平台的灵活性和可移植性，而不依赖于任何特定于供应商的硬件加速特性。

在本节开发的示例视觉管道中，我们做了两个基本假设。首先，DSP 专用于传感器处理和光图像预处理，以平衡系统负载。第二，CPU和 GPU 用于视觉管道后续部分的下游，因此 CPU 与 GPU 的选择取决于所使用的算法。

由于带有可编程 alu 的计算单元通常是所有工具和开发人员关注的焦点，因此我们将在本章后面的“视觉算法优化和调整”一节中关注编程加速替代方案；此外，还将调查选定的优化资源和软件构建模块。

在图 8-2 所示的假想系统中，计算单元包括通用 CPU、一个主要用于图形和媒体加速和一些 GPGPU 加速的 GPU，以及一个用于传感器处理的 DSP。每个计算单元都是可编程的，并包含一个带有调整指令集的通用 ALU。例如，一个 CPU 包含通用编程的所有必要指令，也可能包含 SIMD 指令(在本章后面讨论)。GPU 包含平方根、反正切等超越指令，以及加速图形处理的相关指令。DSP 同样具有针对传感器处理而调整的指令集，可能是 VLIW 指令集。

硬件加速器通常是为常见的操作而构建的，例如 DSP 中用于传感器处理的几何校正单元和 GPU 中用于扭曲曲面片的纹理采样器。计算机视觉还没有标准，新的算法改进正在不断开发，因此除了嵌入式和特殊用途的系统外，没有什么动力为计算机视觉加速器添加任何专用芯片。相反，找到使用现有加速器的创造性方法可能会被证明是有益的。

在本章的后面，我们将讨论在各种计算单元上优化软件的方法，充分利用每个 ALU 和指令集的优势和预期用途。

电源使用

在没有非常详细的功率分析的情况下，很难量化 SOC 或单个计算设备上的特定算法所使用的功率量；可能模拟是最好的方法。通常，为 SOC 开发视觉管道的系统工程师没有精确的功耗测量方法，只有简单的方法，如运行实际完成的应用程序和测量壁功率或电池消耗。

功耗问题有时与使用的计算设备有关，例如 CPU 与 GPU，因为每个设备都有不同的门数和时钟频率，因此消耗功率的速度也不同。由于 GPU 和 CPU 设计的芯片架构师都在努力提供最高的*性能*每*瓦特*每*平方毫米*，(我们假设每组芯片架构师都同样高效)，在 CPU 与 GPU 的功率/性能竞赛中没有明显的赢家。与其他地方(如数据组织和内存架构)相比，通过使用 GPU 而不是 CPU 来节省功率的研究甚至可能不值得付出努力。

在 SIMD 和 SIMT 并行代码的情况下，权衡功率和性能的一种方法是使用 OpenCL 之类的语言，它支持在 CPU 或 GPU 上运行相同的代码。然后需要在每个计算设备上测量性能和功率，以量化实际功率和性能；在“视觉算法优化和调优”一节中，将有更多关于这个主题的讨论。

有关使用在特定 CPU 和 GPU 以及集群上运行的相同 OpenCL 代码的详细性能分析，请参见国家超级计算应用中心的出色研究[544]。此外，请参阅由主要 OpenCL 供应商(如英特尔、NVIDIA 和 AMD)提供的技术计算资源，了解他们在 CPU 和 GPU 上运行相同代码的 OpenCL 编译器的详细信息。有时结果会令人惊讶，尤其是对于多核 CPU 系统与较小的 GPU。

一般来说，视觉管道的计算部分无论如何都不是消耗能量的地方；大部分功率消耗在内存子系统和 I/O 结构中，这些地方需要高数据带宽来保持计算流水线元素满负荷运行。事实上，所有的寄存器文件、高速缓存、I/O 总线和主存储器消耗了大部分的功率和大量的硅不动产。因此，在任何降低功耗的尝试中，内存使用和带宽都是高价值的攻击目标。内存副本越少，缓存命中率越高；本地寄存器文件中相同数据的重用越多越好。

内存使用

就电源和性能而言，内存是最重要的管理资源。开发视觉管道的大部分注意力都放在算法和处理流程上，这已经足够具有挑战性了。然而，视觉应用对存储系统的要求很高。图像本身的大小并不大，但当我们考虑帧速率和通过视觉管道为内核操作读写像素的次数时，内存传输带宽活动就变得更加清晰了。内存系统非常复杂，由每个计算单元旁边的本地寄存器文件、缓存、I/O 结构互连和系统内存组成。在本节中，我们将讨论几个内存问题，包括:

*   像素分辨率、位精度和图像总尺寸
*   视觉管道中的内存传输带宽
*   图像格式，包括灰度和色彩空间
*   特征描述符大小和类型
*   匹配和定位所需的精度
*   特征描述符数据库大小

为了探究内存使用情况，我们将详细介绍局部兴趣点和特征提取场景，假设我们首先定位兴趣点，根据某些标准过滤兴趣点以选择一个较小的集合，计算所选兴趣点周围的描述符，然后根据数据库匹配特征。

一个合理的初步估计是，图像中 0.05%到 1%的像素的下限和上限之间可以产生不错的兴趣点。当然，这完全取决于:(1)图像纹理的复杂程度，(2)使用的兴趣点方法。例如，一幅纹理丰富、对比度高的图像会比一幅被云层包围、纹理和对比度很低的远处的山的图像产生更多的兴趣点。此外，兴趣点检测器方法产生不同的结果——例如，快速角点方法可能比 SIFT 比例不变狗特征检测到更多的角点，参见[附录 A](09.html) 。

描述符大小可能是一个重要的变量，参见[表 8-2](#Tab2) 。640x480 的图像将包含 307，200 个像素。我们估计 1%的上限，或 3072 个像素，可能有不错的兴趣点；我们假设 0.05%的下限是 153。我们提供了第二个估计，即兴趣点可以被进一步过滤，以便为给定的应用挑选出最佳的兴趣点。因此，如果我们假设实际上可能只有 33%的兴趣点被保留，那么我们可以说 153 * 33 到 3，072 * 33 个兴趣点是特征描述的良好候选。这种估计变化很大，当然取决于图像纹理、使用的兴趣点方法和兴趣点过滤标准。假设一个特征描述符的大小是 256 字节，每帧的总描述符大小是 3072x256x.33 = 259，523 字节最大值—这并不极端。然而，当我们考虑特征匹配阶段时，特征描述符计数和存储器大小将是一个问题，因为每个提取的特征必须与数据库中的每个训练特征集匹配。

[表 8-2](#_Tab2) 。每帧描述符字节(1%兴趣点)，改编自[141]

![image](images/Table8-2.jpg)

一般来说，本地二进制描述符提供了低内存占用的优势。例如，如 Miksik 和 Mikolajczyk [141]所述，表 8-2 提供了用于比较的几个描述符的字节数。这里对数据进行了注释，为各种分辨率添加了描述符工作内存大小，单位为每帧字节数。

在[表 8-2](#Tab2) 中，图像帧分辨率在第 1 行，每帧像素数在第 2 行，以字节为单位的典型描述符大小在后续行。所选描述符的总字节在第 1 列，其余各列显示每帧的总描述符大小，假设每帧中估计有 1%的像素用于计算兴趣点和描述符。实际上，我们估计 1%是每帧描述符计数的上限估计，0.05%是下限估计。请注意，基于设计优化，以字节为单位的描述符大小与表中的不同。

内存带宽通常是一个隐藏的成本，并且在优化周期结束之前经常被忽略，因为开发算法通常具有足够的挑战性，而不需要担心内存访问模式和内存流量。[表 8-2](#Tab2) 包括各种图像帧尺寸和特征描述符尺寸的几个内存变量的汇总。例如，使用第 2 行中的 1080p 图像像素计数作为基础，我们看到每个颜色通道 16 位的 RGB 图像将消耗:

![image](images/Eqn8-1.jpg)

并且如果我们包括需要保持的灰度通道 ***I*** 周围，从 RGB 计算，RGBI 的总大小增加到:

![image](images/Eqn8-2.jpg)

如果我们假设每秒 30 帧，两个 RGB 摄像头用于深度处理+I 通道，将完整的 4 通道 RGBI 图像对移出 DSP 所需的存储器带宽接近 1GB /秒:

![image](images/Eqn8-3.jpg)

因此，我们在本例中假设大约 1GB/秒的基线内存带宽，只是为了将映像对从 ISP 向下游移动。我们现在忽略传感器处理的 ISP 存储器读/写要求，假设巧妙的 DSP 存储器缓存、寄存器文件设计和汇编程序中的循环展开方法可以减少存储器带宽。

通常，来自计算单元中的寄存器文件的存储器在单个时钟周期内传输；来自不同高速缓存层的存储器可能需要几十个时钟周期；来自系统内存的内存可能需要数百个时钟周期。在内存传输期间，CPU 或 GPU 中的 ALU 可能处于空闲状态，等待内存。

内存带宽分布在 ALU 处理器旁边的快速寄存器文件中，并通过内存缓存甚至系统内存，因此分析实际内存带宽相当复杂。尽管此处提供了一些内存带宽数字，但这只是为了说明活动。

并且存储器带宽仅在 DSP 的下游增加，因为每个图像帧将在图像预处理期间被读取并可能被重写几次，然后在兴趣点生成和特征提取期间再次被读取。例如，如果我们假设在 ***I*** 通道上仅使用 5×5 内核进行一次图像预处理操作，则每个 ***I*** 像素被读取另外 25 次，希望是从存储器高速缓存线和快速寄存器中读取。

这种内存流量并不都来自慢速系统内存，它主要发生在快速内存缓存系统和快速寄存器文件中，直到出现缓存未命中或快速寄存器文件重载。然后，性能会下降一个数量级，等待缓冲区提取和寄存器重载。如果我们在 ***I*** 通道上增加一个 FAST9 兴趣点检测器，则每个像素会被读取 81 次(9x9)，可能是从内存缓存线或寄存器中读取。如果我们在大约 0.05%的检测到的兴趣点上添加一个异常特征描述符，我们将每个描述符添加 41×41 像素读取以获得该区域(加上 45×2 读取用于 41×41 区域内的点对比较)，希望是从存储器高速缓存线或寄存器。

通常图像会被处理成各种格式，例如图像预处理的 RGB 颜色来增强图像，以及转换成灰度强度 ***I*** 来计算兴趣点和特征描述符。RGB 之间的颜色转换是一种隐藏的内存成本，需要数据复制操作和颜色转换的临时存储，为了获得最佳精度，通常以浮点形式完成。因此，颜色转换可能会多消耗几 GB/秒的内存带宽。对于所有的内存活动，可能会将全部或部分所需的图像缓存到较慢的系统内存中，从而降低非线性性能。

因此，描述符的内存大小是整个视觉管道中的一个考虑因素。首先，我们考虑何时提取特征；第二，我们查看特征何时被匹配并从特征数据库中检索。在许多情况下，特征数据库的大小是内存领域的关键问题，因为要匹配的所有描述符的总大小会影响静态内存存储大小、内存带宽和模式匹配率。在分类和训练期间将特征空间缩减为可快速搜索的格式通常是至关重要的。除了第 4 章中讨论的优化分类方法，数据组织问题可能主要在标准计算机科学搜索、分类和数据结构领域；在第 4 章的[中提供了一些讨论和参考。](04.html)

当我们查看特征数据库或训练集时，内存大小可能是需要应对的主要问题。是否应该将整个特征数据库保存在云服务器上进行匹配？还是应该将整个特征数据库保存在本地设备上？是否应该使用在本地设备上从服务器缓存部分特征数据库的方法？所有上述方法目前都在实际系统中使用。

总之，内存、缓存和寄存器文件远远超过了计算单元中 ALU 处理器的芯片面积。通过视觉管道的 SOC 结构的存储器带宽是功率和性能的关键，要求快速的存储器架构和存储器高速缓存排列，以及仔细的软件设计。然而，内存大小本身并不是全部，因为每个字节都需要在计算单元之间移动。因此，除了小型应用程序之外，仔细考虑内存占用和内存带宽是非常重要的。

通常，仅通过仔细关注内存问题就可以显著提高性能和功耗。在本章的后面，我们将介绍几种有助于减少内存带宽和提高内存性能的设计方法，例如锁定内存中的页面、流水线代码、循环展开和 SIMD 方法。在视觉管道中最小化内存流量的未来研究是一个值得的领域。

输入/输出性能

在这里，我们将 I/O 主题作为一个一般的性能问题，包括计算单元之间的 SOC I/O 结构上的数据带宽、来自摄像机的图像输入，以及将数据库流量匹配到存储设备的功能描述符。我们在讨论内存时提到了 I/O 问题，因为像素数据在 I/O 总线上沿着视觉管道在各种计算设备之间移动。一个主要的 I/O 考虑是在特征匹配时特征描述符数据移出数据库，因此使用较小的描述符并使用有效的机器学习和分类方法优化特征空间是有价值的。

另一种要考虑的 I/O 是摄像机输入本身，它通常通过标准的 MIPI 接口来完成。然而，可以使用任何总线或 I/O 结构，例如 USB。如果视觉流水线设计包括完整的硬件/软件系统设计，而不仅仅是标准 SOC 上的软件，那么就值得特别关注摄像机的硬件 I/O 子系统设计，以及与硬件辅助数据库进行图像存储器传输的专用快速总线。当考虑功率时，I/O 结构硅面积和功率远远超过 ALU 处理器的面积和功率。

愿景管道示例

在本节中，我们来看看视觉管道的四个假设示例。选择每一个来说明来自第 5 章中介绍的视觉度量分类的独立描述符族，包括直方图和颜色匹配等全局方法、快速兴趣点与反常描述符相结合等局部特征方法、傅立叶描述符等基空间方法，以及使用形态学和整体对象形状度量的基于形状的方法。这些示例被分解为*阶段*、*操作、*和*资源、*，如图[图 8-1](#Fig1) 所示，用于以下应用:

*   **汽车识别，** 利用形状和颜色
*   **人脸识别，**利用稀疏局部特征
*   **图像分类，**使用全局特征
*   **增强现实，**使用深度信息和跟踪

这些例子都不包括分类、训练和机器学习的细节，这超出了本书的范围(机器学习参考资料在[第 4 章](04.html)中提供)。假设存储特征描述符的简单数据库对于该讨论是足够的，因为这里的焦点是图像预处理和特征描述阶段。在完成示例并探索计算资源分配的替代类型(如 GPU 与 CPU)后，本章最后讨论了每种计算资源的优化资源和技术。

汽车识别

在这里，我们设计了一个视觉管道，通过使用*多边形形状描述符*和*精确颜色匹配*来识别汽车或机器零件等物体。例如，多边形形状度量可用于测量汽车的长度和宽度，而颜色匹配可用于测量油漆颜色。在某些情况下，如定制汽车油漆工作，颜色本身不足以识别。

对于这个汽车示例，主要的设计挑战包括从道路上分割汽车、匹配油漆颜色以及测量汽车尺寸和形状。整个系统包括一个 RGB-D 相机系统，精确的颜色和光照模型，以及几个协同使用的特征描述符。参见图 8-3 。我们通过这个例子详细探讨了此类完整视觉管道设计的挑战和可能的解决方案。

![9781430259299_Fig08-03.jpg](images/9781430259299_Fig08-03.jpg)

[图 8-3](#_Fig3) 。使用基于形状和基于颜色的视觉管道的汽车识别应用的设置。RGB 和 D 摄像机安装在路面上方，直接向下看

我们根据以下要求定义系统:

*   120 fps 的 1080p RGB 彩色视频(1920x1080 像素)，水平安装以提供最高的长度分辨率，每种颜色 12 位，65 度 FOV。
*   1080p 立体深度相机，8 位 Z 分辨率，120 fps，65 度 FOV。
*   图像 FOV 覆盖 4 条迎面而来的交通车道，宽 44 英尺，长 60 英尺，当交通停止时，足以在每条车道上行驶大约 3 辆正常汽车的长度。
*   限速 25 英里/小时，相当于每秒 37 英尺。
*   摄像机安装在头顶上的停车灯旁边，配有路灯用于夜间照明。
*   具有 4 个 CPU 内核的嵌入式 PC，具有 SIMD 指令集、一个 GPU、8GB 内存、80GB 磁盘；假设高端 PC 具有同等性能(为简洁起见，未指定)。
*   实时识别汽车 以确定品牌和型号；还包括每个事件的发生次数、时间戳和置信度得分。
*   汽车由主要制造商提供的地面真实训练数据集，包括几何图形，以及用于库存模型的所有车身颜色的精确颜色样本；无法识别定制颜色和售后颜色。
*   汽车的平均尺寸从 5 到 6 英尺宽，12 到 16 英尺长。
*   准确率达到 99%或更高。
*   简化的鲁棒性标准，包括噪声、照明和运动模糊。

分割汽车

为了从路面上分割出汽车，使用了一个以 1080p 120fps(每秒帧数)运行的立体深度摄像机，这使得利用深度将每辆汽车从路面上分离出来变得简单。为了实现这一点，开发了一种将深度相机校准到基线道路表面的方法，允许将汽车识别为高于道路表面。我们在这里画出深度校准方法以供说明。

在深度图上观察到球面深度差异，主要影响 FOV 的边缘。为了校正球面场失真，使用合适的校准深度函数(将在现场通过分析确定)来校正每个图像，然后处理每个水平线，考虑在边缘处更大的曲线真实深度距离，以设置每个线的深度相等。

由于速度限制是 25 英里/小时，或每秒 37 英尺，以 120 FPS 成像产生的最大运动模糊约为 0.3 英尺，或每帧 4 英寸。由于一个像素的长度被确定为 0.37 英寸，如图 8-4 所示，从像素计算汽车长度的能力在大约 4 英寸/0.37 英寸= 11 个像素的范围内是准确的，或者大约是一辆 12 英尺长的汽车以 25 英里/小时的速度行驶的 3%，包括运动模糊。然而，可以在图像预处理期间对每个 RGB 和深度图像应用运动模糊补偿，以有效地进一步减少运动模糊；存在几种基于在多个连续图像上使用卷积或补偿的方法[305，492]。

![9781430259299_Fig08-04.jpg](images/9781430259299_Fig08-04.jpg)

[图 8-4](#_Fig4) 。用于汽车识别的特征

匹配油漆颜色

我们假设，在许多情况下，仅使用油漆颜色来识别车辆是可能的，因为每个制造商都使用专有颜色，因此可以采用精确的色度学。为了匹配油漆颜色，每个颜色通道 12 位应提供足够的分辨率，这是在颜色匹配阶段使用 CIECAM02 模型和 ***Jch*** 颜色空间【253】确定的。这需要开发几个具有不同照明条件下的场景的摄像机的校准设备模型，例如在一天的不同时间的全日照、云层、清晨和黄昏的弱光条件以及夜间使用安装在交通上方的照明器灯以及摄像机和停车灯。

色度准确度的关键是设备模型对各种照明条件的考虑。测量色温的光传感器，连同一天中的时间和一年中的季节的知识，被用于选择正确的设备模型，以用于一天中的时间和一年中的季节的适当照明。然而，脏车给颜色搭配带来了问题；现在我们忽略这个细节(自定义油漆工作也是一个问题)。在某些情况下，颜色描述符可能没有用或不可靠；在其他情况下，仅颜色就足以识别汽车。参见第 2 章中[关于色彩管理的讨论。](02.html)

测量汽车尺寸和形状

对于汽车的尺寸和形状，最好的测量方法是直视汽车，以减少透视失真。如图 8-4 中的[所示，使用来自立体摄像机的深度信息，结合汽车形状的多边形形状分割，汽车被分割成 C(货物)、T(顶部)和 H(发动机罩)区域。为了计算形状，基于测试期间的最佳结果，将使用 RGB 和 D 图像的某种加权组合来生成单个图像。我们假设摄像机安装在所有车道中央的最佳位置，但是在 FOV 的远端会存在一些透视失真。我们还假设应用几何校正来将图像校正成笛卡尔对齐。假设用于调整 FOV 的几何校正所引入的误差可以忽略不计，使用最小尺寸为 5' x 12 '的汽车作为例子，预计长度和宽度的近似尺寸精度如下:](#Fig4)

![image](images/Eqn8-4.jpg)

本例使用了以下形状特征:

*   包含所有特征的边界框；使用宽度和长度
*   在汽车区域中间计算的质心
*   从通过质心到周长的最短直径计算的单独宽度
*   以与汽车前部的距离测量的后视镜特征；镜像位置是边界框内最小和最大的周长宽度点
*   使用深度将形状分割成三个区域；在每个区域测量颜色:货舱(C)、顶部(T)和发动机罩(H)
*   周长形状的傅立叶描述符，通过以 5 度的间隔测量从质心到周长点的线段来计算

特征描述符

几个特征描述符一起用于识别，并且汽车识别的置信度基于来自所有描述符的组合分数。要提取的关键特征描述符如下:

*   **汽车形状因素:** 对道路上方的每辆汽车进行基于深度的分割，用于粗略的形状轮廓。随后进行一些形态学处理来清理边缘和去除噪声。对于每个分割的汽车，为面积、周长、质心、边界框和周长形状的傅立叶描述符计算对象形状因子。边界框测量整体宽度和高度，傅立叶描述符测量圆度和形状因子；一些汽车更加方方正正，一些更加弯曲。(有关形状描述符的更多信息，参见[图 6-32](06.html#Fig32) 、[图 2-18](02.html#Fig18) 和[第 6 章](06.html)。有关深度传感器的更多信息，请参见第 1 章。)此外，计算后视镜与汽车前方的距离；镜子位于对象周界周围的宽度极值处，对应于边界框的宽度。
*   **汽车区域分割** **:** 进一步分割使用基于深度的几个单独的汽车区域，即发动机罩、车顶和行李箱。创建一个简单的直方图来收集深度统计矩，执行诸如 K-means 的聚类算法来形成三个主要的深度聚类:车顶将是最高的，发动机罩和行李箱将是第二高的，窗户将在中间(敞篷车缺少顶部区域，此处不包括)。发动机罩、车顶、行李箱和车窗的像素区域被用作描述符。
*   **汽车颜色** **:** 被分割的发动机罩、车顶和行李箱区域的主要颜色被用作颜色描述符。色彩在 ***Jch*** 色彩空间中处理，这是 CIECAM 系统的一部分，可产生高精度。从颜色样本中提取主色信息，并根据照明模型进行归一化。在多种油漆颜色的情况下，会对每种颜色进行单独的颜色标准化。(有关色度的更多信息，请参见第 3 章。)

校准、设置和地面真实数据

关于场景设置、摄像机校准和其他校正，做出了几个关键假设；我们总结如下:

*   **道路深度面:**深度相机校准到路面，作为分割路面上方汽车的参考；仅具有道路的基线深度图被校准作为参考并用于实时分割。
*   **设备模型:**每辆汽车的模型都是根据制造商的信息创建的，每个品牌和模型都有精确的车身几何形状和颜色。定制油漆的汽车混淆了这种方法；然而，形状描述符和汽车区域深度分割提供了一个安全选项，可能足以给出良好的匹配——只有测试才能确定。
*   **光照模型:**为各种条件创建模型，如晴天和阴天的晨光、日光和晚光；基于一天中的时间、一年中的时间和天气条件来选择照明模型，以获得最佳匹配。
*   **用于校正的几何模型:**为 RGB 和深度相机设计整个 FOV 的模型，在每个新帧应用以校正图像。

管道阶段和操作

假设系统预先完全校准，完整管道的基本实时处理流程如图 8-5 所示，分为三个主要操作阶段。注意，完整的流水线包括图像预处理阶段，用于在 FOV 中对准图像并分割特征，特征描述阶段，用于计算形状和颜色描述符，以及用于特征匹配的对应阶段，用于开发由形状和颜色特征的加权组合组成的最终汽车标签。我们假设在一些标准数据库中，每个特性有一个单独的数据库表就可以了。

这里没有尝试创建优化的分类器或匹配阶段；相反，我们假设，在没有证明或测试的情况下，使用标准数据库通过几千个汽车对象的品牌和模型进行的强力搜索对 ALPHA 版本很有效。

注意在[图 8-5](#Fig5) (右下角)中，每辆汽车都是逐帧跟踪的，我们在此不定义跟踪方法。

![9781430259299_Fig08-05.jpg](images/9781430259299_Fig08-05.jpg)

[图 8-5](#_Fig5) 。利用多边形形状特征和颜色进行汽车识别的假想视觉流水线操作

运营和计算资源

对于流水线阶段的每个操作，我们现在探索到可用计算资源的可能映射。首先，我们回顾一下示例系统中可用的主要资源，它包含 8GB 的快速内存，我们假设有足够的空闲空间来映射和锁定内存中的整个数据库以避免分页。我们的系统包含四个 CPU 内核，每个内核都具有 SIMD 指令集，以及一个能够同时运行 128 个 SIMT 线程的 GPU，128GB/s 的内存带宽可供 GPU 和 CPU 共享内存，功能足够强大。让我们假设，总的来说，计算和内存资源对我们的应用程序来说是很好的，不需要考虑特殊的内存优化。接下来，我们看一下为计算资源分配操作的粗粒度优化。表 8-3 提供了对可能的资源分配的评估。

[表 8-3](#_Tab3) 。将操作分配给计算资源

![9781430259299_Table08-03.jpg](images/9781430259299_Table08-03.jpg)

资源分配标准

在我们的简单示例中，如[表 8-3](#Tab3) 所示，为计算单元分配算法的主要标准是处理器适用性和处理器间的负载平衡；对于这种应用，电源不是问题。[图 8-5](#Fig5) 中提供的资源分配操作是这个假设设计练习的起点；实际的优化会有所不同，根据性能分析进行调整。然而，假设每个算法所使用的内存访问模式是显而易见的，我们可以根据内存访问模式很好地猜测资源分配。在二阶分析中，我们还可以考虑跨管道的负载平衡，以最大化计算单元的并行使用；然而，这需要实际的性能测量。

在这里，我们将暂时将[表 8-3](#Tab3) 中的任务分配给资源。如果我们看看内存访问模式，使用 GPU 执行顺序任务 2 和 3 是有意义的，因为我们可以首先将图像映射到 GPU 内存空间，然后使用 GPU 执行三个顺序操作。GPU 有一个纹理采样器，我们将任务 2 分配给它，使用四点扭曲进行几何校正。一些 DSP 或相机传感器处理器也有一个能够进行几何校正的纹理采样器，但在我们的例子中没有。除了几何校正，运动模糊也是 GPU 的一个很好的候选，它可以在着色器中有效地实现为区域操作。对于更高端的 GPU，在媒体部分甚至可能有运动模糊补偿的硬件加速。

稍后，在流水线中，在任务 4 和 5 中图像已经被分割之后，任务 6 中的形态学阶段可以使用 GPU 着色器快速执行；然而，将图像移入和移出 GPU 进行形态学处理的成本实际上可能比在 CPU 上执行形态学处理要慢，因此需要进行性能分析，以做出关于 CPU 与 GPU 实施的最终设计决策。

在阶段 7 到 11 的情况下，如[表 8-3](#Tab3) 所示，面积、周长、质心和其他测量的算法跨越了一个非局部化的数据访问模式。例如，周界追踪沿着汽车的边缘。因此，我们将使用单个 CPU 通过图像来跟踪周长，并计算每辆汽车的面积、质心和边界框。然后，我们将每个边界框作为一个图像块分配给一个单独的 CPU 线程，用于计算剩余的测量值:径向线段长度、傅立叶描述符和镜像距离。然后每个边界框被分配给一个单独的 CPU 线程，用于计算每个区域的色度，包括货物、车顶和发动机罩，如[表 8-3](#Tab3) 所示。每个 CPU 线程使用 C++进行颜色转换，并试图使用编译器标志来强制 SIMD 指令优化。

使用形状和颜色特征可以逐帧跟踪汽车；然而，我们在这里不开发跟踪算法。对于通信和匹配，我们依赖于来自第三方的通用数据库，该数据库在 CPU 上的独立线程中运行，与管道的早期阶段并行执行。我们假设数据库可以将自己的工作分成并行线程。然而，稍后的优化阶段可以重写并创建更好的数据库和分类器，使用并行线程来匹配特征描述符。

面孔、情绪和年龄识别

在这个例子中，我们设计了一个使用局部特征描述符和兴趣点的人脸、情感和年龄识别管道。人脸识别涉及识别一个独特的人的独特的脸，而人脸检测只涉及确定人脸的位置和感兴趣的特征，如情绪、年龄和性别。我们的例子是面部检测，并找到对象的情绪和年龄。

为简单起见，本例使用固定摄像机拍摄的单人面部照片进行生物识别，以进入安全区域。使用面部照片大大简化了这个例子，因为不需要从许多角度和距离在人群中挑选人脸。关键的设计挑战包括找到一个可靠的兴趣点和特征描述符方法来识别关键的面部标志，确定情绪和年龄，并在标准化的相对坐标系中对标志进行建模，以便计算距离比和角度。

用于生物识别的优秀面部识别系统已经部署了几十年，使用了广泛的方法，实现了接近 100%的准确率。在本练习中，不试图证明性能或准确性。我们根据以下要求定义系统:

*   1080p RGB 彩色视频(1920x1080 像素)，30 fps，水平安装以提供最高的长度分辨率，每种颜色 12 位，65 度 FOV，30 FPS
*   图像 FOV 覆盖 2 英尺高，1.5 英尺宽，足够一个完整的头部和肩膀顶部
*   背景是白色下拉屏幕，便于分割
*   照明位于对象的前方稍上方，在整个面部投射微弱的阴影，突出眼睛、嘴唇和鼻子周围的角落
*   对于每个面部，系统识别以下标志:
    *   眼睛:两个眼角和一个眼心
    *   主要眼睛颜色:在 CIECAM02 JCH 颜色坐标中
    *   主面颜色:CIECAM02 JCH 颜色坐标
    *   眉毛:眉弧的两个端点和一个中心，用于确定情绪
    *   鼻子:鼻尖上的一个点和鼻孔旁边的两个最宽点，用于决定情感和性别
    *   嘴唇:嘴唇的两个端点，上唇的两个中心脊
    *   脸颊:每个脸颊中心一分
    *   下巴:一个点，下巴的底点，可能会因为面部毛发而不可靠
    *   头顶:一分；可能由于发型而不可靠
    *   独特的面部标志:这些标志可能包括胎记、痣或疤痕，并且必须落在围绕面部区域计算的边界框内

*   在原始图像上的每个检测到的标志处计算异常特征
*   准确率达到 99%或更高
*   简化的鲁棒性标准，仅包括比例

请注意，情绪、年龄和性别都可以从选定的相对距离和面部特征的比例来估计，并且我们假设人脸解剖学专家提供了用于真实系统的正确位置和比例。参见图 8-6 。

![9781430259299_Fig08-06.jpg](images/9781430259299_Fig08-06.jpg)

[图 8-6](#_Fig6) 。(左)基于头部和面部区域的边界框的比例比率作为预测面部标志位置的指导方针。(右)带有检测到的面部标志位置以及标志之间测量的相对角度和距离的注释图像。相对测量值用于确定情绪、年龄和性别

为该示例系统计算的特征集包括:

1.  诸如眼睛、眉毛、鼻子和嘴的面部标志的相对位置
2.  地标之间的相对比例和比率，以确定年龄、性别和情感
3.  每个地标的反常描述符
4.  眼睛颜色

校准和地面实况数据

校准很简单:在拍摄对象的背后使用白色背景，拍摄对象站在离相机大约 4 英尺的地方，可以拍摄头部和肩膀上部。(我们将在本节稍后讨论用于从背景区域分割头部的操作。)假设我们有一个 1080p 的图像，我们将 1920 个像素分配给垂直方向，1080 个像素分配给水平方向。

假设摄影师足够好，能够将头部置于图像的中心，使头部占据大约 50%的水平像素和大约 50%的垂直像素，那么头部的像素分辨率为大约 540 像素水平和大约 960 像素垂直，这对于我们的应用程序来说足够好，并且对应于头部高度与宽度的比率。由于我们假设男性和女性成年人的平均头部高度约为 9 英寸，宽度为 6 英寸，使用我们对距离相机 4 英尺的假设，我们有足够的像素精度和分辨率:

![image](images/Eqn8-4.jpg)

地面真实数据包括:(1)已知人的面部照片，以及(2)一组用于帮助定位面部标志的相关模板形式的标准眼睛标志特征(相关模板的稀疏码本)。有两组相关模板:一组用于基于使用 Hessian 检测器找到的位置的*精细特征*，另一组用于基于使用基于可控滤波器的检测器找到的位置的*粗糙特征*(精细和粗糙检测器将在本示例的后面更详细地描述)。

由于像眼睛和嘴唇这样的面部特征在人与人之间非常相似，所以典型的界标特征相关模板仅提供界标及其位置的粗略识别。提供了覆盖所有标志的年龄和性别范围的几个模板，例如眼角、眉角、眉峰、鼻角、鼻底、唇角和唇中心区域形状。为了简洁起见，我们在这里不开发用于相关性模板的基础事实数据集，但是我们假设该过程是使用通过扭曲或改变真实特征并针对几个真实人脸测试它们以得到最佳典型特征集而创建的合成特征来完成的。相关模板用于面部标志识别阶段，稍后讨论。

兴趣点位置预测

为了找到面部标志，如眼睛、鼻子和嘴巴，这个示例应用程序通过使用面部照片进行了简化，使面部特征的位置可预测，并允许在预测的位置智能搜索每个特征。对于这个例子，我们使用来自人体解剖学的基本比例假设(被艺术家使用了几个世纪)来预测面部特征位置，并允许在预测的位置搜索面部特征，而不是求助于头部尺寸和形状的科学研究。面部特征比例主要因年龄、性别和种族而异；例如，典型的成年男性比率如[表 8-4](#Tab4) 所示。

[表 8-4](#_Tab4) 。面部和头部特征的基本近似比例

| 头部高度 | 头部宽度 X 1.25 |
| 头部宽度 | 头部高度 X .75 |
| 面部高度 | 头部高度 X .8 |
| 表面宽度 | 头部高度 X .8 |
| 眼睛位置 | 眼睛中心距离左/右边缘 30%,距离顶部 50% |
| 眼睛长度 | 头部宽度 X 1.25 |
| 眼间距 | 头部宽度 X .5 |
| 鼻部位置 | 比唇角高 25% |
| 鼻子长度 | 头部高度 X .25 |
| 唇角 | 大约眼中心 *x* ，比下巴 *y* 高 15%左右 |
| 嘴/嘴唇宽度 | 头部宽度 X .07 |

![image](images/sq.jpg) **注**[表 8-4](#Tab4) 中的信息是根据初级艺术家的材料合成的，用于说明目的，并不保证准确。

要建立的最基本的坐标是头部的边界框。根据边界框，可以预测其他标志面部特征位置。

使用边界框分割头部和面部

如前所述，脸部照片是在白色背景下从大约 4 英尺的距离拍摄的，允许简单地分割头部。我们对简单的颜色强度使用阈值处理，如***【RGBI-1】，*** ，其中 I = (R=G + B) / 3，并且白色水滴背景被识别为最高强度。

被分割的头部和肩部区域用于创建头部和面部的边界框，这将在下面讨论。(注意:狂野发型需要另一种方法，也许是基于面部特征相对于头型和比例的相对大小和位置。)在分割头部的边界框之后，我们继续分割面部区域，然后找到每个标志。头部边界框的粗略尺寸分两步计算:

1.  Find the top and left, right sides of the head— *Top*<sub>*xy*</sub>*, Left*<sub>*xy*</sub>, *Right*<sub>*xy—*</sub>which we assume can be directly found by making a pass through the image line by line and recording the rows and columns where the background is segmented to meet the foreground of head, to establish the coordinates. All leftmost and rightmost coordinates for each line can be saved in a vector, and sorted to find the median values to use as Right<sub>x</sub> / Left<sub>x</sub> coordinates. We compute head width as:

    *H**T3】w**=右* *<sub>x</sub>* *-左* *<sub>x</sub>*

2.  Find the chin to assist in computing the head height H<sub>h</sub>. The chin is found by first predicting the location of the chin, then performing edge detection and some filtering around the predicted location to establish the chin feature, which we assume is simple to find based on gradient magnitude of the chin perimeter. The chin location prediction is made by using the head top coordinates *Top*<sub>*xy*</sub> and the normal anatomical ratio of the head height *H*<sub>*h*</sub> to head width *H*<sub>*w,*</sub> which is known to be about 0.75\. Since we know both *Top*<sub>*xy*</sub>  and *H*<sub>*w*</sub>  from step 1, we can predict the *x* and *y* coordinates of the chin as follows:

    ![image](images/Eqn8-5.jpg)

实际上，在某些情况下，发型会使头部的分割变得困难，因为头发可能在顶部堆积得很高，或者在两侧延伸得很宽，覆盖了耳朵。然而，我们可以重复几次下巴检测方法来找到最佳下巴，或者假设我们的分割方法将通过头发过滤器模块以某种方式解决这个问题，因此为了简洁起见，我们继续这个例子。

为了定位下巴位置，在预测位置周围使用水平边缘检测掩模，因为下巴主要是水平边缘。对连接的水平边缘最大值的坐标进行过滤，找到水平边缘集合的最低 *y* 坐标，将最低 x/y 坐标的中值作为下巴中心位置的初始猜测。稍后，当眼睛位置已知时，下巴 *x* 位置可以通过眼睛之间的中点位置进行检查，并在需要时重新计算。参见[图 8-7](#Fig7) 。

![9781430259299_Fig08-07.jpg](images/9781430259299_Fig08-07.jpg)

[图 8-7](#_Fig7) 。面部标志的位置。(左)使用 Hessian 张量的最大特征值增强的面部标志[493]用于生成 Hessian 特征值的 ImageJ 的 FeatureJ 插件(由 Erik Meijering 开发的 FeatureJ)。；注意提供额外细节的细微边缘。(中心)基于模板的特征检测器，使用具有沿着 Canny 检测器[400]的线的附加滤波的可操纵滤波器来提供粗略的细节。(右)用于计算中心图像的方向可调滤波器模式。使用对比窗口重新映射来突出边缘，从而增强两幅图像

包含面部的头部边界框被假定为:

*   *BoundingBoxTopLeftx = Leftx*
*   *BoundingBoxTopLefty = Topy*
*   *boundingbox bottom right = right*
*   *boundingbox bottom right = chiny*

面部标志识别和计算机特征

既然计算了头部边界框，就可以使用[表 8-4](#Tab4) 中的基本比例估计来预测面部标志特征集的位置。在每个预测位置周围进行搜索以找到特征；参见[图 8-6](#Fig6) 。例如，眼睛的中心位置从两侧向内大约 30 %,从头顶向下大约 50%。

在我们的系统中，我们使用具有两个级别的图像金字塔来进行特征搜索，粗级别搜索被下采样四次，以及全分辨率的精细级别搜索来重新定位兴趣点，计算特征描述符，并进行测量。从粗到细的方法允许头部的相对尺寸有很大的变化，以考虑到由于与照相机的距离和/或由于年龄造成的头部尺寸的差异而产生的轻微比例不变性。

在头部倾斜的情况下，我们不在这里增加一个步骤来旋转垂直于笛卡尔坐标的头部；然而，这很容易做到。例如，可以使用迭代过程来最小化正交边界框的宽度，使用从-10 度到+10 度每 2 度进行几次图像旋转。为每次旋转计算边界框，并且取最小的边界框宽度来找到用于校正头部倾斜的图像的角度。

此外，我们没有在这里添加计算皮肤表面纹理的步骤，这对于年龄检测以发现皱纹是有用的，这可以通过分割几个皮肤区域，例如前额、眼角和嘴周围的区域，并使用边缘或纹理度量计算表面纹理(皱纹)来容易地完成。

地标检测步骤包括特征检测、特征描述和计算地标之间的位置和角度的相对测量值，如下所示:

1.  计算兴趣点:在搜索面部特征之前，使用兴趣点检测器来计算预测位置周围的可能候选位置。这里，我们使用两个检测器的组合:(Hessian 张量的最大特征值[493]，以及(2)使用类似于 Canny 方法[400]的边缘检测过滤标准处理的可控过滤器[388]，如图 8-7 所示。Hessian 和 Canny-like 边缘检测器图像之后是对比度窗口以增强边缘细节。Hessian 风格和 Canny 风格的图像一起用于在接下来的相关阶段中对最佳兴趣点的实际位置进行投票。
2.  使用相关性计算界标位置:使用前面描述的一组规范的相关性模板来确定每个面部界标特征的最终位置，包括眼角、眉角、眉峰、鼻角、鼻底、唇角和唇中心区域形状。开始相关搜索的预测位置是来自步骤 1 的两个检测器的平均位置:(Hessian 方法提供精细特征细节，(2)而方向可调滤波器方法提供粗略特征细节。测试将确定相关性本身是否足够，而不需要来自步骤 1 的兴趣点。
3.  使用反常描述符描述地标:对于步骤 2 中找到的每个地标位置，我们计算反常描述符。SIFT 可能同样有效。
4.  使用 CIECAM02 JCH 测量主要眼睛颜色:我们使用超像素方法[257，258]分割出眼睛中心周围的颜色区域，并制作超像素细胞颜色的直方图。眼睛的黑色瞳孔和白色应该聚集成直方图中的峰值，并且眼睛的主色也应该聚集在直方图中。使用直方图对应的方法，甚至可以识别多种颜色的眼睛。
5.  计算界标之间的相对位置和角度:在上面的步骤 2 中，使用相关性来找到每个特征的位置(如果需要，达到亚像素精度[468])。如[图 8-6](#Fig6) 所示，我们使用地标位置作为测量几个特征相对距离的基础，例如:
    1.  眼睛距离，中心到中心，对年龄和性别有用
    2.  眼睛大小，从眼角到眼角
    3.  眉毛角度，从末端到中心，对情感有用
    4.  眉毛到眼睛的角度，两端到中间的位置，有助于表达情感
    5.  眉毛到眼睛中心的距离，对情感有用
    6.  嘴唇或嘴的宽度
    7.  中央唇线与唇角成角度，有助于表达情感

管道阶段和操作

管线阶段和操作如图[图 8-8](#Fig8) 所示。为了对应，我们假设每个特征有一个单独的数据库表。我们对创建优化的分类器来加速模式匹配不感兴趣；暴力搜索没问题。

![9781430259299_Fig08-08.jpg](images/9781430259299_Fig08-08.jpg)

[图 8-8](#_Fig8) 。使用局部特征的面部、情感和年龄检测的假想视觉管道中的操作

运营和计算资源

对于这个例子，大部分是最适合 CPU 的直线代码。以数据访问模式为指导，边界框、相对距离和比率、反常描述符和通信是 CPU 的良好选择。在某些情况下，可以使用单独的 CPU 线程，例如在单独的线程中计算每个界标处的异常描述符(对于这个简单的应用程序，线程可能是多余的)。我们假设使用标准数据库进行特征匹配。我们的申请被认为有足够的时间等待信件。

有些操作适合 GPU 例如区域操作，包括 Hessian 和 Canny-like 兴趣点检测器。可以使用单个公共数据读取循环和组合处理循环将这些方法组合并优化到单个着色器程序中，该程序将输出生成两个图像，每个检测器一个图像。此外，我们假设 GPU 为媒体部分中的快速、硬件加速的相关块匹配器提供 API，因此我们利用了硬件加速的相关。

资源分配的标准

在这个例子中，性能不是问题，所以使用计算机资源的标准放宽了。事实上，所有代码都可以编写为在单个 CPU 上的单个线程中运行，并且在我们的目标系统假设下，性能可能足够快。然而，[表 8-5](#Tab5) 中所示的资源分配旨在说明每个操作的资源的合理使用，以在 SOC 中分配工作负荷。

[表 8-5](#_Tab5) 。将操作分配给计算资源

![9781430259299_Table08-05.jpg](images/9781430259299_Table08-05.jpg)

图像分类

在我们的下一个例子中，我们设计了一个简单的图像分类系统，用于移动电话，目标是识别相机视野中的主要对象，如建筑物、汽车和人。对于图像分类应用，感兴趣的是整个图像，而不是特定的局部特征。用户将拥有一个简单的应用程序，允许他们将相机指向一个对象，并从一侧到另一侧摇动相机，以建立 MVS 深度感测的立体基线，稍后讨论。可以应用多种全局度量(如第 3 章所述)，对整个图像进行计算，如纹理、颜色或强度直方图以及连通分量标记方法。此外，局部特征(如[第 6 章](06.html)所述)可用于描述图像的关键部分。这个假设的应用程序同时使用了全局和局部特性。

我们根据以下要求定义系统:

*   1080p RGB 彩色视频(1920x1080 像素)，每秒 30 帧，每种颜色 12 位，65 度 FOV，每秒 30 帧
*   图像 FOV 涵盖了手机摄像头拍摄的无限聚焦视图
*   无限制的照明条件(好的和坏的)
*   准确率达到 90%或更高
*   简化的鲁棒性标准，包括比例、透视、遮挡
*   对于每个图像，系统计算以下特征:
    *   *全局 RGBI 直方图，*在 RGB-I 颜色空间
    *   *GPS 坐标，*既然手机有 GPS
    *   *通过 MVS 深度感测的相机姿态，*使用加速度计数据对正交 FOV 平面进行几何校正(用户被要求在指向对象的同时挥动相机，相机姿态向量根据加速度计数据计算，并使用 ICP 相对于 FOV 中的主要对象)
    *   *筛选特征，*理想情况下，为每幅图像存储 20 到 30 个特征
    *   *通过单目密集深度传感的深度图，*用于分割出 FOV 中的对象，深度范围目标为 0.3 米至 30 米，1 米处的精度在 1%以内，30 米处的精度在 10%以内
    *   *场景标记和像素标记，*基于分割区域的属性，包括 RGB-I 颜色和 LBP 纹理

场景识别是一个经过充分研究的领域，每年都会举行几场大型挑战比赛，以使用已建立的地面真实数据集来寻找提高准确性的方法，如[附录 B](10.html) 所示。在挑战中，各类图像的最佳准确率从 50%到 90%以上不等。在本练习中，不试图证明性能或准确性。

分割图像和特征描述符

对于这个假设的视觉管道，将同时使用几种用于将场景分割成对象的方法，而不是依赖于单一方法，如下所示:

1.  **密集分割、场景解析、物体标注:**使用单目 MVS 生成的深度图，用于分割场景中常见的物品，包括地面或地板、天空或天花板、左右墙壁、背景、场景中的被摄物。为了从移动电话设备计算单目深度，应用程序提示用户在大约 3 英尺的手臂长度范围内从左向右移动相机，以创建一系列宽基线立体图像，用于使用 MVS 方法计算深度(如第一章中的[所述)。MVS 提供了密集的深度图。即使 MVS 计算是计算密集型的，这也不是问题，因为我们的应用不需要连续的实时深度图生成——只需要单个深度图；对于我们假设的移动设备来说，3 到 4 秒获取基线图像并生成深度图被认为是可能的。](01.html)
2.  **使用超像素的颜色分割和分量标记:**使用超像素的颜色分割应该大致对应于深度分割的部分。
3.  **LBP 区域分割:**这种方法计算起来相当快，表示起来也很简洁，正如在[第 6 章](06.html)中所讨论的。
4.  **融合分割:**使用布尔掩码和形态学以及一些逻辑将深度、颜色和 LBP 分割区域组合成融合分割。该方法使用迭代循环来将颜色、深度和 LBP 分割方法之间的差异最小化到新的融合分割图中。融合分割图是一种全局图像描述符。
5.  **每个分割区域的形状特征:**为每个融合的分割区域计算基本形状特征，例如面积和质心。区域质心之间的相对距离和角度也被计算到复合描述符中。

在这个假设的例子中，我们一起使用几个特征描述符方法来获得额外的鲁棒性和不变性，以及一些预处理，概括如下:

1.  整个图像中的 SIFT 兴趣点被用作附加线索。我们完全遵循 SIFT 方法，因为已知 SIFT 使用三个或四个 SIFT 特征来识别较大的对象[161]。然而，基于训练结果，我们期望将 SIFT 特征计数限制为每个场景 20 或 30 个强候选特征。
2.  此外，由于我们在移动电话上有加速度计和 GPS 传感器数据，我们可以使用传感器数据作为仅基于位置和相机姿势识别对象的提示，例如假设存在服务器来查找某个区域中地标的 GPS 坐标。
3.  由于需要照明不变性，我们执行 RGBI 对比度重映射，试图在 SIFT 特征计算、颜色直方图和 LBP 计算之前标准化对比度和颜色。基于地面真实数据测试，我们假设用于计算最佳强度重新映射限制的统计方法被用于展开颜色的总范围以减轻黑暗和过饱和图像，但是我们没有花时间在这里开发算法；然而，在第 2 章中提供了关于候选算法的一些讨论。例如，在暗图像上计算 SIFT 描述符可能不能提供足够的边缘梯度信息来计算好的 SIFT 描述符，因为 SIFT 需要梯度。过饱和的图像会有褪色的颜色，从而影响良好的颜色直方图。
4.  融合分割结合了所有颜色、LBP 和深度分割方法的优点，通过将所有分割融合到融合分割图中来最小化分割差异。还使用 LBP，它对弱光和过饱和条件都不太敏感，提供一些平衡。

同样，本着假设练习的精神，除了上面给出的基本描述之外，我们在这里不花时间开发算法。

管道阶段和操作

管线阶段如[图 8-9](#Fig9) 所示。它们包括图像预处理阶段，主要用于校正图像对比度、计算深度图和分割图。特征描述阶段计算 RGBI 颜色直方图、SIFT 特征、结合最佳深度、颜色和 LBP 方法的融合分割图，然后将像素标记为连通分量。为了对应，我们假设每个特征有一个单独的数据库表，使用强力搜索；未尝试优化。

![9781430259299_Fig08-09.jpg](images/9781430259299_Fig08-09.jpg)

[图 8-9](#_Fig9) 。使用全局特征的假想图像分类流水线中的操作

将工序映射到资源

我们假设 DSP 提供了一个用于对比度重映射的 API，由于 DSP 已经在处理来自传感器的所有像素，并且像素数据已经存在，因此对比度重映射非常适合 DSP。

MVS 深度图计算遵循线和区域操作的数据模式。我们使用 GPU 来完成 MVS 算法的重要部分，比如左/右图像对模式匹配。我们的算法遵循基本的立体算法，如第一章中所讨论的。立体基线最初是从加速度计估计的，然后在基线图像集上的一些束调整迭代被用于改进基线估计。我们假设 MVS 立体声工作负载是流水线中最重的，在一两秒钟内消耗了大部分 GPU。最后产生密集的深度图，用于深度分割。

使用超像素方法对 RGBI 分量进行颜色分割[257，258]。还在 RGBI 中为每个超像素单元计算颜色分量的直方图。LBP 纹理计算非常适合 GPU，因为它是一种符合着色器编程风格的区域操作。因此，可以将颜色分割和 LBP 纹理分割组合到同一个着色器中，以利用寄存器文件中的数据共享，并避免数据交换和数据复制。

SIFT 特征描述可以分配给 CPU 线程，数据可以在 CPU 线程之间平铺和划分，用于并行特征描述。同样，融合分段也可以分配给 CPU 线程和数据块。注意，切片数据可能包括重叠边界区域或缓冲区，见后面的[图 8-12](#Fig12) 了解重叠数据切片的说明。也可以使用平铺数据区域，以类似的方式将标记分配给并行 CPU 线程。最后，我们假设一个蛮力匹配阶段，使用每个描述符的数据库表来开发最终得分，并且基于对地面真实数据的训练，我们在最终得分中对一些特征比其他特征加权更多。

资源分配的标准

资源分配的基本标准是在 DSP 上执行早期点处理，因为数据已经驻留，然后使用 GPU SIMT SIMD 模型作为着色器来计算区域操作，以创建深度图、颜色分割图和 LBP 纹理图。流水线的最后阶段很好地映射到线程并行方法和数据分块。给定[表 8-6](#Tab6) 中所示的选择的资源分配操作，该应用程序似乎完全可以在线程和 GPU 中跨 CPU 内核进行工作负载平衡和并行化。

[表 8-6](#_Tab6) 。将操作分配给计算资源

![9781430259299_Table08-06.jpg](images/9781430259299_Table08-06.jpg)

增强现实

在第四个示例中，我们使用可穿戴显示设备(如眼镜或护目镜和可穿戴相机)设计了一个用于设备维护的增强现实应用。整个系统由一个便携式可穿戴设备组成，该设备带有摄像头和显示器，通过无线连接到服务器。处理分布在可穿戴设备和服务器之间。(**注:**由于实际系统的设计、训练和测试会很复杂，因此这个例子非常高级，并且省略了很多细节。)

服务器系统包含机器的所有 CAD 模型，并提供从任何视点对任何机器部件的按需图形模型或渲染。可佩戴的摄像机跟踪眼睛的注视和机器的位置。该可佩戴显示器允许维修技术人员查看机器并观看显示器上的增强现实覆盖图，说明如何维修机器。当用户看着给定的机器时，增强现实特征识别机器部件，并提供覆盖图和动画来帮助故障排除和修理。该系统使用 RGB 图像的组合作为 3D 深度表面上的纹理，以及机器和所有组成机器部件的 3D CAD 模型的数据库。

该系统将有以下要求:

*   1080p RGB 彩色摄像机(1920x1080 像素)，每秒 30 帧，每种颜色 12 位，65 度 FOV，每秒 30 帧
*   1080p 立体深度相机，8 位 Z 分辨率，60 fps，65 度 FOV；所有的立体处理都在相机 ASIC 中的硅片上进行，深度图作为输出
*   480p 近红外摄像机对准技术人员的眼睛，用于视线检测；近红外相机在头戴式显示器周围的低光环境中成像更好
*   1080p 可穿戴 RGB 显示器
*   驱动摄像机和显示器、描述符生成以及与服务器的无线通信的可穿戴 PC；该系统采用电池供电，适合移动使用，电池续航时间为 8 小时
*   包含机器和零件的 CAD 模型的服务器；每个部分将具有预先计算到数据库中的相关描述符；服务器可以通过无线向可穿戴设备提供图形模型或完整的渲染
*   服务器包含地面实况数据，该数据由根据每个零件的 CAD 模型渲染计算的特征描述符+机器零件每个描述符的标准化 3D 坐标组成
*   简化的鲁棒性标准包括透视、缩放和旋转

校准和地面实况数据

我们假设 RGB 相机和立体相机系统用正确的光学器件校准以精确成像相同的 FOV，因为 RGB 相机和 3D 深度图必须在每个像素位置对应，以使 2D 特征能够与对应的 3D 深度位置精确关联。然而，眼睛注视相机将需要一些独立的校准，我们假设开发了一个简单的校准应用程序，通过使用立体和 RGB 相机来定位 FOV 中的特征，然后在监视器上叠加眼睛注视向量以确认眼睛注视向量的准确性，来学习技术人员的眼睛位置。我们在这里不开发校准过程。

然而，地面真实数据需要一些时间来开发和训练，并且需要机器的维修和设计专家在训练期间一起工作。地面实况数据包括每个部分的特征集，包括沿角、边和其他位置(如旋钮)的 2D SIFT 特征。为了创建 SIFT 特征，首先从技术人员可能看到的代表性视点制作每个 CAD 零件模型的一组图形渲染，然后在图形渲染上计算 2D SIFT 特征，并且使用模型的几何来创建每个 SIFT 特征的相对 3D 坐标以进行对应。

2D SIFT 特征位置与相对 3D 坐标一起记录在数据库中，并使用合适的约束条件(如角度和相对距离)关联到对象中，参见[图 8-10](#Fig10) 。在训练过程中，专家为每个零件选择一个最小的特征集，主要是来自表面拐角和边缘的最强特征。2D SIFT 特征之间的三维相对角度和距离被记录在数据库中，以提供透视、比例和旋转不变性。所有零件的 3D 坐标都标准化为机器的尺寸。此外，每个零件表面的主色和纹理是根据渲染计算的，并存储为纹理和颜色特征。这个系统需要大量的培训和测试。

特征和对象描述

在现场的实际使用中，RGB 相机用于寻找 2D SIFT、LBP 和颜色特征，而立体相机用于创建深度图。因为 RGB 图像和深度图是像素对齐的，所以每个特征具有取自深度图的 3D 坐标，这意味着 3D 坐标可以被分配给 2D SIFT 特征位置。2D SIFT 特征位置之间的 3D 角度和 3D 距离被计算为约束，并且具有 3D 位置约束的组合 LBP、颜色和 2D SIFT 特征被存储为 SIFT 顶点特征并被发送到服务器用于对应。关于 SIFT 顶点描述符和零件对象的布局，参见[图 8-10](#Fig10) 。注意，3D 坐标与几个描述符相关联，包括 SIFT、LBP 纹理和 RGB 颜色，类似于在计算机图形中通过 3D 位置、颜色和纹理来表示 3D 顶点的方式。在训练期间，从部件的各种视图创建若干 SIFT 顶点描述符，每个视图由数据库中的 3D 坐标关联，允许基于 3D 坐标以及特征的简化搜索和匹配。

![9781430259299_Fig08-10.jpg](images/9781430259299_Fig08-10.jpg)

[图 8-10](#_Fig10) 。SIFT 顶点描述符类似于使用 3D 位置、颜色和纹理的计算机图形顶点。SIFT 顶点描述符包含来自 RGB 相机的 2D SIFT 描述符、从深度相机生成的 2D SIFT 描述符的 3D 坐标、SIFT 顶点处的 RGB 颜色以及 SIFT 顶点处的 LBP 纹理。零件对象包含 SIFT 顶点描述符的列表，以及 SIFT 顶点列表中每个 3D 坐标之间的相对角度和距离

覆盖和跟踪

在服务器中，将场景中的 SIFT 顶点描述符与数据库进行比较，以找到零件对象。在搜索之前，每个特征的 3D 坐标、角度和距离相对于机器的尺寸被标准化。如[图 8-10](#Fig10) 所示，SIFT 特征在一个 3D 坐标上被组合成一个 SIFT 顶点描述符，具有相关的 2D SIFT 特征、LBP 纹理和颜色。SIFT 顶点描述符与零件对象相关联，零件对象包含描述每个零件的顶点坐标列表，以及 SIFT 顶点特征之间的相对角度和距离。

假设可以使用一小组 SIFT 顶点特征来定义机器零件对象，则可以实时确定尺寸和距离，并且可以连续计算相对 3D 信息，例如每个零件和整个机器的尺寸和位置。使用所识别的部件和特征的 3D 坐标，可以在头戴式显示器中显示增强现实渲染，突出显示部件位置，并使用叠加动画来说明要移除的部件，以及手在修理过程中要遵循的路径。

近红外摄像机跟踪技术人员的眼睛，以在场景上创建 3D 凝视向量。凝视矢量可用于头戴式显示器中的增强现实“帮助”覆盖，允许凝视导向的缩放或信息，为技术人员正在查看的部件显示更详细的渲染和覆盖信息。

管道阶段和操作

管线阶段如[图 8-11](#Fig11) 所示。请注意，处理在可穿戴设备(主要用于图像捕捉、功能描述和显示)和用于繁重工作负载(如通信和增强现实渲染)的服务器之间进行。在本例中，可穿戴设备与服务器结合使用，依靠无线网络传输图像和数据。我们假设无线网络上的数据带宽和数据压缩方法足以满足所有必要的数据通信。

![9781430259299_Fig08-11.jpg](images/9781430259299_Fig08-11.jpg)

[图 8-11](#_Fig11) 。假想的增强现实管道中的操作

将工序映射到资源

我们尽可能少地使用 GPU 进行 GPGPU 处理，并假设服务器有许多可用的 CPU，我们在管道末端使用 GPU 进行图形渲染。大多数操作使用数据分块很好地映射到单独的 CPU 线程。注意，一个服务器通常有许多高功率和快速的 CPU，所以使用 CPU 线程是一个很好的匹配。参见[表 8-7](#Tab7) 。

[表 8-7](#_Tab7) 。将操作分配给计算资源

![9781430259299_Table08-07.jpg](images/9781430259299_Table08-07.jpg)

资源分配的标准

在移动设备上，深度图是在深度相机上的硅中计算的。我们使用 GPU 通过纹理采样器执行 RGB 和深度图对齐，然后在 CPU 上执行 SIFT 计算，因为必须首先进行 SIFT 计算，以使顶点锚定并计算多元描述符信息。我们继续并遵循数据局部性，并使用数据平铺和重叠区域在单独的 CPU 线程中为每个 2D SIFT 点执行 LBP 和颜色计算。参见后面的[图 8-12](#Fig12) 了解重叠数据平铺的图示。

![9781430259299_Fig08-12.jpg](images/9781430259299_Fig08-12.jpg)

[图 8-12](#_Fig12) 。数据平铺成四个重叠的平铺块。瓦片重叠特定的量，在这种情况下是 16 个像素，允许诸如卷积之类的区域操作读取而不是写入重叠区域，以从相邻区域组装卷积核数据。然而，每个线程仅写入其瓦片内的非重叠区域。每个图块都可以分配给单独的线程或 CPU 内核进行处理

在服务器上，我们已经分配了 CAD 数据库和大部分繁重的工作负载，包括特征匹配和数据库访问，因为服务器预期具有大的存储和内存容量以及许多可用的 CPU。此外，我们希望延长电池寿命并最大限度地减少移动设备的发热，因此服务器是大多数工作负载的首选。

加速替代方案

有多种常见的加速方法 *参见*可以应用于视觉流水线的加速方法，包括关注内存管理、使用线程的粗粒度并行、使用 SIMD 和 SIMT 方法的数据级并行、多核并行、高级 CPU 和 GPU 汇编语言指令以及硬件加速器。

有两种基本的加速方法:

1.  跟着数据走
2.  遵循算法

优化计算设备的算法，如 SIMD 指令集或 SIMT GPGPU 方法，也称为*流处理*，通常是设计师考虑的显而易见的选择。但是，针对数据流和数据驻留进行优化可以产生更好的结果。例如，在计算资源和数据格式之间来回转换数据不是一个好主意；它消耗了复制和格式转换操作所消耗的时间和能量。慢速系统内存中的数据复制比计算单元内快速寄存器文件中的数据访问慢得多。考虑到内存速度的内存架构层次，如图 8-2 中的[所示，并考虑到计算机视觉的图像密集型特征，最好找到跟踪数据的方法，并尽可能长时间地将数据保存在快速寄存器和高速缓冲存储器中，位于计算单元的本地。](#Fig2)

内存优化

优化成像或视觉应用时，对内存占用和内存传输带宽的关注是最常被忽视的方面。如[表 8-2](#Tab2) 和下面的内存讨论所示，视觉管道通过系统在计算单元和系统内存之间传输几 GB/S 的数据。此外，兴趣点检测和图像预处理等区域处理会通过各计算单元的寄存器文件、高速缓存和系统内存以复杂的路径移动更多数据。

为什么要针对内存进行优化？通过优化内存使用，减少了数据传输，提高了性能，降低了功耗，延长了电池寿命。权力是昂贵的；事实上，一家大型互联网搜索公司已经在哥伦比亚河的水电系统附近建立了服务器农场，以保证清洁电力和降低电力传输成本。

对于移动设备来说，电池寿命是最关心的问题。政府也开始发行碳税和碳信用来鼓励减少能源消耗。因此，内存使用是一个经常被忽略的成本。每个计算平台和操作系统的内存优化 API 和方法都有所不同。参考文献[494]中对 Linux 的内存优化方法进行了很好的讨论。

最小化计算单元之间的内存传输

如果可能，应避免计算单元之间的数据传输。在优化和调优阶段应考虑工作负载整合，以便在同一数据驻留在给定计算单元的寄存器文件和本地缓存中时，对其执行尽可能多的处理。也就是跟着数据走。

例如，使用 GPGPU 着色器进行单区域操作，则在 CPU 上处理相同的数据可能会比在 CPU 上执行所有处理慢。这是因为 GPGPU 内核需要设备驱动程序干预来为每个内核设置内存并启动每个内核，而 CPU 程序直接访问代码和数据，除了初始程序加载之外，不需要设置驱动程序。减少计算单元之间来回切换的一种方法是使用循环合并和任务链接，这将在本节稍后讨论。

内存平铺

当将粗粒度并行性的工作负载划分到几个线程中时，可以将映像分成多个平铺区域，并将每个平铺区域分配给一个线程。平铺适用于点、线和区域处理，其中每个线程在平铺区域上执行相同的操作。通过允许瓦片之间的重叠读取区域，消除了硬边界，并且像卷积这样的区域操作可以读取到相邻的瓦片中用于内核处理，以及将完成的结果写入它们的瓦片中。

DMA、数据复制和转换

通常，视觉管道中需要图像的多个副本，在某些情况下，数据必须从一种类型转换为另一种类型。一个例子是将存储在 16 位整数中的 12 位无符号颜色通道数据转换成 32 位整数，从而允许下游计算中更准确的数值精度。此外，颜色通道可以被转换到选择的颜色空间，例如 RGBI，用于 I 分量空间*(R * G * B)/3 = I；*然后，新的 I 值被混合并复制回 RGB 分量。仔细注意数据布局和数据驻留将允许更有效的向前和向后颜色转换。

复制数据时，最好尝试使用直接内存访问(DMA) 单元，以便尽可能快地复制数据。DMA 单元在硬件中实现，直接优化和控制进出存储器的 I/O 互连流量。操作系统提供 API 来访问 DMA 单元[494]。优化 DMA 方法有多种多样，在参考文献[497，495]中可以找到一些比较视觉应用中缓存性能与 DMA 性能的有趣资料。

寄存器文件、内存缓存和锁定

内存系统是每个处理器的虚拟和物理内存的层次结构，由慢速固定存储组成，如文件系统、页面文件和交换文件，用于管理虚拟内存、系统内存、高速缓存和计算单元内的快速寄存器文件，以及它们之间的内存互连。如果要处理的数据驻留在寄存器文件中，则由 ALU 以处理器时钟速率处理。最佳情况下，存储器访问是通过靠近每个 ALU 的寄存器文件进行的，因此将数据保存在寄存器中并在复制数据之前执行所有可能的处理是最佳选择，但这可能需要更改一些代码(本节稍后讨论)。

如果必须访问高速缓存才能获得数据，那么与访问寄存器文件相比，会消耗更多的时钟周期(功率消耗、性能损失)。并且如果存在高速缓存未命中，并且必须访问慢得多的系统存储器，则通常需要数百个时钟周期来通过高速缓存将存储器移动到寄存器文件以进行 ALU 处理。

操作系统提供 API 来锁定或固定内存中的数据，这通常会增加缓存中的数据量，减少分页和交换。(交换是一种隐藏的复制操作，由操作系统自动执行，以便在系统内存中腾出更多空间)。当数据被频繁访问时，数据将驻留在更快的高速缓冲存储器中，如图 8-2 中的[所示。](#Fig2)

数据结构、打包和矢量与分散-收集数据组织

所使用的数据结构会增加内存流量。数据组织应尽可能允许连续块中的串行访问，以提供最佳性能。从编程的角度来看，数据结构的设计通常考虑到了方便性，没有注意编译器将如何安排数据或由此产生的性能。

例如，考虑一个数据结构，它有几个由字节、整数和浮点数据项组成的字段；编译器可能试图重新安排数据项在数据结构中的位置，甚至为了各种优化以不同的顺序打包数据。编译器通常提供一组编译器指令，如内嵌编译指令和编译器开关，来控制数据打包行为；这些都是值得研究的。

对于点处理，数据的向量是自然结构，并且存储系统将在访问和处理连续向量时以最高性能运行。对于区域操作，使用跨越几行的矩形，并且矩形导致可能产生高速缓存未命中的存储器访问模式。使用分散-收集操作来收集卷积核数据允许将大型数据结构分割成数据向量，从而提高性能。通常，CPU 和 GPU 内存架构会特别关注数据访问模式，并提供隐藏的优化方法。

分散-收集操作，也称为*矢量 I/O* 或*跨步*内存访问，可以在 GPU 或 CPU 芯片中实现，以实现对非连续数据结构模式的快速读/写访问。通常，分散操作将多个输入缓冲区写入单个输出缓冲区中的连续模式，而收集操作类似地将多个输入缓冲区读取到输出缓冲区中的连续模式。

操作系统和计算语言为分散-聚集操作提供了 API。对于 Linux 风格的操作系统，参见 POSIX 1003.1-2001 规范中规定的 *readv* 和 *writev* 函数。OpenCL 为分散-聚集提供了`async_work_group_strided_copy`函数。

粗粒度平行度

通过将工作分解成线程，以及将工作分配给多个处理器内核，可以使用粗粒度并行性来实现视觉流水线。粗粒度并行性可以通过将计算工作负载分解为线程管道，或将内存分解为分配给多个线程的小块来实现。

以计算为中心与以数据为中心

粗粒度并行可以通过以计算为中心和以数据为中心的 方法来实现。例如，在以*计算为中心的*方法中，视觉流水线阶段可以沿着流水线阶段划分到独立的执行线程和计算单元中，数据通过队列和 FIFOs 一次一点地进入下一个阶段。在*以数据为中心的*方法中，图像可以被分割成小块，如图 8-12 中的[所示，每个线程处理一个独立的小块区域。](#Fig12)

线程和多核

有几种方法可以将线程分布到多个 CPU 内核上，包括依靠操作系统调度程序来优化每个 CPU 内核的使用并执行负载平衡。另一种方法是将特定的任务分配给特定的 CPU 内核。每个操作系统都有不同的控件可用于调整每个线程的进程调度器，并且还可以提供将特定线程分配给特定处理器的能力。(我们将在本章后面讨论粗粒度线程的编程资源、语言和工具。)每个操作系统都会提供一个线程化的 API，比如 *pthreads* 。参见[图 8-13](#Fig13) 。

![9781430259299_Fig08-13.jpg](images/9781430259299_Fig08-13.jpg)

[图 8-13](#_Fig13) 。(左)典型 SIFT 描述符流水线计算分配[180]。(右)ORB、SURF 和 SIFT 的报告计算时间[120]是 24 个 640x480 图像的平均值，每个图像包含约 1，000 个特征。在某些应用中，为 SIFT 改造 ORB 可能是一个不错的选择

细粒度数据并行性

细粒度并行性是指利用并行性的数据组织和相应的处理器架构，传统上称为*阵列处理器或矢量处理器*。并非所有应用都是数据并行的。部署非数据并行代码在数据并行机器上运行会适得其反；最好用 CPU 和直线代码启动。

数据并行操作应该表现出常见的内存模式，例如大型规则数据阵列，如像素行或像素块，它们以相同的方式处理。回头参考[图 8-1](#Fig1) ，注意一些算法是对点、线和像素区域的向量进行操作的。这些数据模式和相应的处理操作本质上是数据并行的。点操作的例子是颜色校正和数据类型转换，区域操作的例子是卷积和形态学。有些算法是直线代码，分支多，并行少。通过 SIMD 和 SIMT 方法直接支持细粒度的数据并行。

SIMD、SIMT 和 SPMD 基本面

昨天的超级计算机现在相当于今天的 GPU 和多核 CPU。科学界对 SIMD、SIMT 和 SPMD 机器及其并行编程语言的性能非常感兴趣。它已经发展了几十年，现在有许多好的资源可以应用于廉价的 SOCs 从国家超级计算应用中心[544]开始。

当内存中的数据布局和算法本身存在细粒度的并行性时，例如对向量进行点、线和区域操作时，可以应用 SIMD 指令和多线程。单指令多数据(SIMD) 指令同时处理一个向量中的几个数据项。为了在 SIMD 级开发细粒度的并行性，计算机语言和相应的 alu 都应该为丰富的矢量数据类型和矢量指令提供直接支持。需要面向向量的编程语言来利用数据并行性，如[表 8-8](#Tab8) 所示；然而，有时编译器开关可用于利用 SIMD。注意像 C++这样的语言不直接支持向量数据类型和向量指令，而数据并行语言支持，如[表 8-8](#Tab8) 所示。

[表 8-8](#_Tab8) 。通用数据并行语言的选择

| 

语言名

 | 

标准或专有

 | 

操作系统平台支持

 |
| --- | --- | --- |
| GLSL 像素着色器 | 标准 OpenGL | 几个操作系统平台 |
| HLSL 像素着色器 | Direct3D | Microsoft 操作系统 |
| 计算着色器 | Direct3D | Microsoft 操作系统 |
| 计算着色器 | 标准 OpenGL | 几个操作系统平台 |
| 使用 | 机器人 | 谷歌 OS |
| OpenCL(打开 CL) | 标准 | 几个操作系统平台 |
| C++放大器 | 微软 | 微软操作系统平台 |
| 库达 | 仅适用于 NVIDIA GPUs | 几个操作系统平台 |
| OpenMP | 标准 | 几个操作系统平台 |

在某些情况下，SIMT 的成本超过了它的收益，特别是考虑到数据设置和拆卸的运行时开销、线程管理、代码可移植性问题以及大型和小型 CPU 和 GPU 之间的可伸缩性。

除了 SIMD 指令之外，必须提供一种启动和管理运行相同代码的大型线程组的方法，以利用数据并行性，称为单指令多线程(SIMT) ，也称为单程序多数据(SPMD) 。SIMT 程序被称为*着色器*，因为历史上计算机图形中使用的像素着色器和顶点着色器是第一个广泛用于开发细粒度数据并行性的程序。着色器也被称为*内核*。

CPU 和 GPU 都支持 SIMD 指令和 SIMT 方法——例如，使用像 OpenCL 这样的语言。CPU 使用操作系统调度程序来管理线程；然而，GPU 使用硬件调度程序、调度程序和记分板逻辑来跟踪线程执行和阻塞状态，允许几个在不同数据上运行相同内核的线程共享同一个 ALU。对于 GPU，每个着色器在 ALU 上运行，直到它在内存传输、函数调用时被阻止，或者当其时间片到期时被 GPU 着色器调度程序换出。

注意，C++ AMP 和 CUDA 似乎都提供了最接近 C++的语言环境。用于 SIMT 编程的编程模型和语言包含运行时执行组件，用于为每个线程封送数据、启动线程以及管理线程组的通信和完成状态。常见的 SIMT 语言见[表 8-8](#Tab8) 。

请注意，CPU 和 GPU 的执行环境在硬件和软件层面有很大的不同。GPU 依赖设备驱动程序进行设置和拆卸，以及固定功能硬件调度，而 CPU 则依赖操作系统调度程序，可能还有微调度程序。CPU 通常用 C 或 C++编程，程序直接从内存中执行，并由操作系统调度，而 GPU 需要用 SIMT SIMD 友好的语言编写着色器或内核程序，如 DirectX 或 OpenGL 中的计算着色器或像素着色器，或 CUDA 或 OpenCL 等 GPGPU 语言。

此外，着色器内核必须经由运行时系统通过设备驱动程序启动到 GPU，并且在执行之前在 GPU 内创建执行上下文。GPU 还可以使用数据必须驻留的专用系统内存分区，在某些情况下，GPU 还会提供专用的快速内存单元。

GPGPU 编程通过运行时系统具有内存数据设置和程序设置开销，除非在 GPU 中顺序执行几个内核以隐藏开销，否则单个内核的设置和拆卸开销可能会超过通过 GPU SIMD/SIMT 处理获得的任何好处。

决定使用数据并行 SIMT 编程模型会影响程序设计和可移植性。SIMT 的使用不是必须的，在任何情况下，必须使用像 C++这样的标准编程语言来控制 SIMT 运行时环境，以及整个视觉管道。然而，数据并行 SIMT 模型的性能优势在某些情况下极具吸引力，是最佳选择。然而，请注意，GPGPU SIMT 编程实际上可能比使用具有 SIMD 指令、粗粒度线程和数据切片的多个 CPU 内核慢，尤其是在 GPU 不支持硬件中足够多的并行线程的情况下，较小的 GPU 就是这种情况。

着色器内核语言和 GPGPU

如[表 8-8](#Tab8) 所示，创建 SIMD SIMT 数据并行代码有几种备选方案，有时也称为 GPGPU 或流处理。如上所述，实际的 GPGPU 程序被称为*着色器*或*内核* 。历史上，像素着色器和顶点着色器是作为 OpenGL 和 DirectX 等图形标准的数据并行语言开发的。然而，随着专为 NVIDIA GPUs 构建的 CUDA 的出现，在 GPU 中实现标准通用计算功能的想法出现了。这个概念在业界得到了认可，尽管还没有杀手级的应用程序，像素着色器也可以用来获得同样的效果。最后每个 GPGPU 编程语言无论如何都要翻译成机器语言，所以很多情况下选择高级 GPGPU 语言可能意义不大。

然而，GPGPU 语言的选择有时会受到供应商操作系统的限制。例如，谷歌、微软和苹果等主要供应商不同意对 GPGPU 采用相同的方法，他们提供不同的语言，这意味着行业范围的标准化仍在进行中，着色器代码的可移植性难以捉摸。也许最接近可移植的标准解决方案是 OpenCL，但是用于 DirectX 和 OpenGL 的计算着色器是可行的替代方案。

高级指令集和加速器

每个处理器都有一套用于加速特定操作的高级指令。有关最新信息，请参考供应商的处理器和编译器文档。高级指令汇总如[表 8-9](#Tab9) 所示。

[表 8-9](#_Tab9) 。高级指令集项目

| 

指令类型

 | 

描述

 |
| --- | --- |
| **透析器** | GPU 有特殊的汇编指令来计算图形渲染数学运算的常见超越数学函数，如点积、平方根、余弦和对数。在某些情况下，CPU 还具有超越功能。 |
| **熔断指令** | 诸如乘法和加法的普通操作通常在单个融合 MADD 指令中实现，其中乘法和加法都在单个时钟周期中执行；指令可以有三个或更多操作数。 |
| **SIMD 指令** | CPU 有 SIMD 指令集，如英特尔 SSE 和英特尔 AVX 指令，AMD 处理器有类似的 SIMD，ARM 处理器有 NEON。 |
| **高级数据类型** | 一些指令集，如用于 GPU 的指令集，提供了公共语言编译器不支持的奇数数据类型，如半字节整数、8 位浮点数和定点数。部分指令集可能支持特殊数据类型，但不是全部。 |
| **内存访问修饰符** | 一些处理器提供跨步存储器访问能力以支持分散-聚集操作、位重组操作以允许寄存器内容以可编程位模式移动和复制，以及置换存储器访问模式以支持跨通道模式。英特尔处理器还为指针检查提供 MPX 内存保护指令。 |
| **安全** | 可以为诸如 SHA 或 AES 密码之类的普通密码提供密码加速器和特殊指令；比如英特尔 AES-NI。此外，英特尔提供了英特尔 SGX 扩展，以提供封闭的内存区域来执行安全软件；恶意软件无法访问被遮挡的区域。 |
| **硬件加速器** | 常见的加速器包括用于图像变形和子采样的 GPU 纹理采样器，以及用于快速内存复制的 DMA 单元。操作系统提供 API 来访问 DMA 单元[494]。图形编程语言如 OpenGL 和 DirectX 提供了对纹理采样器的访问，GPGPU 语言如 OpenCL 和 CUDA 也提供了纹理采样器 API。 |

操作系统供应商提供的 API 可能使用也可能不使用特殊指令。每个处理器厂商的编译器将优化所有代码，以充分利用高级指令的优势；其他编译器可能提供也可能不提供优化。但是，每个编译器将提供不同的标志来控制优化，因此需要进行代码调优和分析。使用汇编语言是获得高级指令集全部性能的最佳方式。

视觉算法优化和调整

优化可以基于直觉或性能分析，通常是两者的结合。假设确定了热点，可以应用本节中讨论的各种优化方法。性能热点可以从数据、算法或两者的角度来解决。大多数时候，内存访问是一种隐性成本，开发者并不理解(算法很难)。然而，内存优化本身就是提高性能的关键。表 8-11 总结了各种优化方法，这将在下面讨论。

每种算法的数据访问模式可以用 Zinner、Kubinger 和 Isaac 分类法[494]来描述，如表 8-10 所示。请注意，通常首选的数据访问模式是就地(IP)计算，它涉及将数据一次性读入快速寄存器，处理并将结果存储在寄存器中，然后将最终结果写回到原始图像之上。这种方法最大限度地利用了高速缓存行和寄存器，避免了在数据被处理之前的较慢内存。

[表 8-10](#_Tab10) 。图像处理数据访问模式分类法(来自 Zinner 等人【494】)

![image](images/Table8-10.jpg)

**IP processing is usually the simplest way to reduce memory read/write bandwidth and memory footprint.*

编译器和手动优化

通常一个好的编译器可以自动执行[表 8-11](#Tab11) 中列出的许多优化；但是，请检查编译器标志以了解选项。优化的目标是保持 CPU 指令执行管道满，或者减少内存流量。然而，[表 8-11](#Tab11) 中的许多优化需要手工编码，将算法归结为更紧密的循环，在快速寄存器中共享更多数据，减少数据复制。

[表 8-11](#_Tab11) 。常见的优化技术、手动和编译方法

| 

名字

 | 

描述

 |
| --- | --- |
| **子函数内联** | 通过内联复制函数代码来消除函数调用 |
| **任务链接** | 将函数的输出逐段送入等待函数 |
| **分支消除** | 重新编码以消除条件分支，或通过组合多个分支条件来减少分支 |
| **循环合并** | 使用更多直线代码将内外循环合并成更少的循环 |
| **包装数据** | 重新安排结构内的数据对齐，并向某些数据项添加填充，以便更好地将数据对齐到更大的数据字或页面边界，从而实现更高效的存储器读写 |
| **循环展开** | 通过在循环内复制代码来减少循环迭代次数；可以使用直线代码复制或通过将多次迭代打包到 VLIW 中来实现 |
| **功能合并*** | 将串行函数重写为单个函数，使用单个外部循环来读写系统内存中的数据；在合并函数之间传递快速寄存器中的小数据项，而不是传递大图像缓冲区 |
| **ROS-DMA*** | 双缓冲 DMA 与处理重叠；DMA 和处理并行发生，在处理过程中 DMA 新数据，DMA 结果输出 |

** Function coalescing and ROS-DMA are not compiler methods, and may be performed at the source code level.* *Note: See references[498,499] for more information on compiler optimizations, and see each vendor’s compiler documentation for information on available optimization controls.*

调谐

优化之后，可以从几个角度来调整工作视觉管道。目标是提供运行时*控件*。[表 8-12](#Tab12) 提供了一些调优控件的例子，这些控件可以实现运行时或编译时调优。

[表 8-12](#_Tab12) 。视觉管道的运行时调节控制

| **图像分辨率** | 允许在八度音阶或其他音阶上的可变分辨率以减少工作量 |
| **每秒帧数** | 跳过帧以减少工作量 |
| **特征数据库的大小和精度** | 寻找减小数据库大小的方法，例如，建立一个精度较高的数据库，另一个精度较低的数据库，每个数据库使用不同的分类器 |
| **特征数据库组织和速度** | 通过更好的组织和搜索来提高性能，可能有多个数据库，每个数据库使用不同的组织策略和分类器 |

特征描述符改进、检测器、距离函数

正如在第 6 章中所讨论的，许多特征描述符方法，如 SIFT，可以进行改造以使用其他表示和特征描述。例如，[第 6 章](06.html)中讨论的 LBP-SIFT 改进使用局部二进制模式来代替 SIFT 使用的梯度方法，以获得令人印象深刻的加速，同时保留 SIFT 管道的其他方面。ROOT-SIFT 方法是另一种 SIFT 加速方法，在[第 6 章](06.html)中讨论。检测器和描述符可以混合和匹配，以实现不变性和性能的不同组合，参见 REIN 框架[397]。

除了描述符提取器本身，距离函数通常在特征匹配阶段消耗相当多的时间。比如 FREAK、ORB 等局部二进制描述符用的是快速的汉明距离，SIFT 用的是欧氏距离，比较慢。改进视觉管道以使用本地二进制描述符是距离函数如何具有显著性能影响的一个例子。

需要指出的是，[第 6 章](06.html)中回顾的描述符通常基于学术研究，而不是基于广泛的工程现场试验和优化。每种方法都只是进一步开发和定制的起点。我们可以肯定的是，军事武器系统已经在部署系统的视觉管道中使用类似但更优化的特征描述方法几十年了。参见[图 8-13](#Fig13) 。

盒子和卷积加速

卷积是特征描述和图像预处理中最常见的操作之一，因此卷积是优化和硬件加速的关键目标。boxlet 方法 [392]近似于卷积，并提供速度与精度的权衡。Boxlets 可用于优化任何严重依赖卷积的系统，如 LeCun 等人使用的卷积网络方法[85，336，339]。基本方法是将一对 2D 信号(核和图像)近似为低次多项式，从而量化每个信号并减少数据量；然后对这两个信号进行微分以获得脉冲函数和卷积近似。通过对微分的结果进行积分，可以恢复完整的卷积。

另一种卷积和通用区域处理加速方法是在快速寄存器中存在重叠数据时，尽可能多地重用重叠数据，而不是为每个操作读取数据项的整个区域。当执行区域操作时，可以编程使用滑动窗口和指针来尝试重用来自已经在寄存器文件中的相邻矩形的数据项，而不是为每个区域操作将完整的新矩形复制到寄存器中。这是另一个适合硅加速的领域。

此外，在某些情况下，分散-收集指令可用于将卷积数据收集到内存中以加速处理，GPU 通常会优化内存架构以实现快速区域操作。

数据类型优化，整数与浮点

软件工程师通常使用整数作为默认的数据类型，很少考虑内存和性能。通常，在数据类型领域的大多数代码中，都有唾手可得的果实。例如，当不需要额外的位精度时，从`int32`到`int16`的数据转换，以及从`double`到`float`的数据转换，都是需要考虑的明显节省空间的项目。

在某些情况下，当整数同样适用时，会使用浮点数据类型。浮点计算通常需要将近四倍的硅面积，这相应地消耗更多的功率。数据类型消耗更多的内存，可能需要更多的时钟周期来计算。作为浮点的替代，一些处理器提供定点数据类型和指令，这可能非常高效。

优化资源

一些软件库和工具形式的资源可用于计算机视觉和图像处理优化。一些列在[表 8-13](#Tab13) 中。

[表 8-13](#_Tab13) 。视觉优化

| 

方法

 | 

加速策略

 | 

例子

 |
| --- | --- | --- |
| 线程库 | 粗粒度并行性 | 英特尔 TBB pthreads |
| 管道构建工具 | 将函数连接到管道中 | PfeLib 视觉管道库[495]卤化物[543]* |
| 原始加速库 | 功能已经过预先优化 | 英特尔 IPP、英伟达 NPP、高通 FastCV |
| GPGPU 语言 | 开发 SIMT SIMD 代码 | CUDA、OpenCL、C++ AMP、英特尔 CILK++、GLSL、HLSL、OpenGL 和 Direct3D 的计算着色器、RenderScript |
| 编译器标志 | 编译器针对每个处理器进行优化；参见[表 8-10](#Tab10) | 特定于供应商 |
| SIMD 指令 | 直接用汇编语言编码，或者使用标准语言的编译器标志，或者使用 GPGPU 语言。 | 特定于供应商 |
| 硬件加速器 | 用于复杂功能的硅加速器 | 纹理采样器；其他由供应商选择性提供 |
| 高级指令集 | 加速复杂的低级运算，或者融合多条指令；参见[表 8-9](#Tab9) | 英特尔 AVX、ARM NEON、GPU 指令集 |

**Open source available.*

摘要

本章通过开发四个纯粹假设的高级应用设计，将前几章的讨论整合成完整的视觉系统。针对每个管道讨论了计算资源分配和优化方案等设计细节，旨在引发关于如何设计高效系统的讨论(示例有时很粗略)。探索的应用包括使用形状和颜色特征的汽车识别、使用稀疏局部特征的人脸和情感检测、使用全局特征的整个图像分类以及增强现实。每个示例说明了来自第 5 章中介绍的[视觉度量分类的不同特征描述符族的使用，例如多边形形状方法、颜色描述符、稀疏局部特征、全局特征和深度信息。在示例中使用了多种特征描述方法来说明预处理阶段的挑战。](05.html)

此外，还对 SOC 架构中计算资源(CPU、GPU 和内存)的优化和负载平衡设计概念进行了一般性讨论，以探索硬件/软件系统挑战，如降低功耗。最后，概述了软件优化资源和具体的优化技术