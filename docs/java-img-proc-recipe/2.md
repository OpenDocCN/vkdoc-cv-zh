© Nicolas Modrzyk 2018 Nicolas ModrzykJava Image Processing Recipes[https://doi.org/10.1007/978-1-4842-3465-5_2](https://doi.org/10.1007/978-1-4842-3465-5_2)

# 2.带折纸的 OpenCV

Nicolas Modrzyk<sup class="calibre11">[1](#Aff2) </sup> (1)Tokyo, Japan  

> 盯着折纸说明书看了足够长的时间后，你就会和它们融为一体，并开始从内部理解它们。
> 
> 祖伊·德佳内尔

![img/459821_1_En_2_Figa_HTML.jpg](Images/459821_1_En_2_Figa_HTML.jpg)

折纸库诞生的动机是，计算机视觉相关的编程应该易于设置、易于运行和易于实验。

这些天，当人工智能和神经网络风靡一时时，我的任务是为各种神经网络准备和生成数据。很快就清楚了，你不能只是将任何类型的图像或视频数据转储到网络，并期望它高效地运行。你需要按照大小、颜色或内容来组织所有这些图像或视频，并尽可能自动处理图像，因为手动整理这十亿张图像可能会非常耗时。

因此，在这一章中，我们将展示 Origami、Clojure 包装器、项目模板和用于 JavaVM 上 OpenCV 库的示例，所有这些都使用一种简洁的语言。

这些示例将通过 Clojure 向您介绍 OpenCV 代码。

您在上一章中看到的设置几乎可以完全原样重用，因此不会浪费时间去学习已经学过的内容。主要是，您只需要将这个库作为一个依赖项添加到一个新创建的项目中。

一旦这个简单的附加设置完成，我们将通过折纸库的视角来回顾 OpenCV 的概念。

## 2.1 开始用 Origami 编码

> 生活本身很简单……只是不容易。
> 
> 史蒂夫马拉博里

### 问题

您已经听说过这个库将 OpenCV 包装在一个名为 Origami 的轻量级 DSL 中，并且您想安装它并在您的机器上尝试一下。

### 解决办法

如果您已经阅读或翻阅了本书的第一章，您会记得 Leiningen 用于创建项目模板并在简单的项目布局中布局文件。

这里，您将使用一个名为 clj-opencv 的不同项目模板，它将下载依赖项并为您复制所需的文件。

然后，您将看到可用于这个新设置的不同编码风格。

### 它是如何工作的

当 Leiningen 仍然安装在您的机器上时，您可以使用与创建基于 Java opencv 的项目相同的方式创建一个基于模板的新项目。

#### 使用 Leiningen 模板的项目设置

这一次，项目模板被命名为 clj-opencv，并使用 Leiningen 在终端或控制台上调用:

lein new clj-opencv myfirstcljcv

这将下载新模板，并创建一个 myfirstcljcv 文件夹，其内容大致如下:

├── notes │   ├── empty.clj │   └── practice.clj ├── output ├── project.clj ├── resources │   ├── XML │   │   ├── aGest.xml │   │   ├── closed_frontal_palm.xml │   │   ├── face.xml │   │   ├── fist.xml │   │   ├── haarcascade_eye_tree_eyeglasses.xml │   │   ├── haarcascade_frontalface_alt2.xml │   │   └── palm.xml │   ├── cat.jpg │   ├── minicat.jpg │   ├── nekobench.jpg │   ├── souslesoleil.jpg │   └── sunflower.jpg └── test     └── opencv3         ├── ok.clj         ├── simple.clj         ├── tutorial.clj         └── videosample.clj 6 directories, 19 files In the preceding file structure

*   notes 是一个包含代码的文件夹，以 notes 的形式提供给 gorilla 和 lein-gorilla。我们将回顾如何使用这两个野兽。

*   project.clj 是已经看到的 leiningen 项目文件。

*   参考资料包含用于练习和 opencv 识别特性的示例图像和 XML 文件。

*   测试包含示例 Clojure 代码，展示如何开始使用 opencv 和 origami。

如您所知，project.clj 文件保存了几乎所有的项目元数据。这一次我们将使用一个版本，它比你在第 [1](1.html) 章中看到的版本稍有更新。

与前一章的主要区别在下面重点介绍，所以让我们快速回顾一下。

 (defproject sample5 "0.1-SNAPSHOT" **:injections [**  **(clojure.lang.RT/loadLibrary org.opencv.core.Core/NATIVE_LIBRARY_NAME)]** **:plugins [[lein-gorilla "0.4.0"]]** :test-paths ["test"] :resource-paths ["rsc"] **:main opencv3.ok** :repositories [   ["vendredi" "https://repository.hellonico.info/repository/hellonico/"]] **:aliases {"notebook" ["gorilla" ":ip" "0.0.0.0" ":port" "10000"]}** :profiles {:dev {   :resource-paths ["resources"]   :dependencies [   ; used for proto repl   [org.clojure/tools.nrepl "0.2.11"]   ; proto repl   [proto-repl "0.3.1"]   ; use to start a gorilla repl   [gorilla-repl "0.4.0"]   [seesaw "1.4.5"]]}} :dependencies [  [org.clojure/clojure "1.8.0"]  [org.clojure/tools.cli "0.3.5"]  **[origami "0.1.2"]**])

正如所料，origami 库已经作为依赖项添加到依赖项部分。

还增加了一个名为 gorilla 的插件。这将帮助你运行 python 的笔记本风格代码；我们将在后面的食谱中介绍这一点。

注入部分一开始可能有点晦涩，但它主要是说本地 OpenCV 库的加载将在启动环境时完成，所以您不必像第一章中的问题那样在所有示例中重复它。

#### 一切都好

要运行的主名称空间是**opencv 3 . ok**；让我们现在运行它，以确保设置就绪。这一点从第一章开始就没有改变，您仍然可以在终端或控制台上使用相同的命令来加载代码:

lein run

在一小段输出之后，您应该能够看到类似这样的内容

Using OpenCV Version:  3.3.1-dev .. #object[org.opencv.core.Mat 0x69ce2f62 Mat [ 1200*1600*CV_8UC1, isCont=true, isSubmat=false, nativeObj=0x7fcb16cefa70, dataAddr=0x10f203000 ]] A new gray neko has arisen! The file grey-neko.jpg would have been created in the project folder and be like the picture in Figure [2-1](#Fig1).![img/459821_1_En_2_Fig1_HTML.jpg](Images/459821_1_En_2_Fig1_HTML.jpg) Figure 2-1

Grey Neko(消歧义)

**opencv3.ok** 名称空间的代码完整编写如下:

(ns opencv3.ok     (:require [opencv3.core :refer :all])) (defn -main [& args]   (println "Using OpenCV Version: " VERSION "..")   (->    (imread "resources/cat.jpg")    (cvt-color! COLOR_RGB2GRAY)    (imwrite "grey-neko.jpg")    (println "A new gray neko has arisen!")))

你会认出前一章中使用的 **imread** 、 **cvtColor** 、 **imwrite** opencv 函数，事实上 java opencv 函数只是简单地包装在 Clojure 中。

This first code sequence flow written in the origami DSL is shown in Figure [2-2](#Fig2).![img/459821_1_En_2_Fig2_HTML.gif](Images/459821_1_En_2_Fig2_HTML.gif) Figure 2-2

第一个 Origami 示例的代码流

#### 网络摄像头检查

如果你有一个网络摄像头插入，有另一个启动摄像头和视频流的例子。运行这个的文件在 **samplevideo.clj** 中。

和前面一样，您可以通过为 lein run 命令指定名称空间来启动示例。

 lein run -m opencv3.videosample When the command starts, you will be presented with a moving view of the coffee shop you are typing those few lines of code in, just as in Figure [2-3](#Fig3).![img/459821_1_En_2_Fig3_HTML.jpg](Images/459821_1_En_2_Fig3_HTML.jpg) Figure 2-3

东京咖啡店

虽然这只是运行项目模板中包含的示例，但是您已经可以开始在自己的文件中编写自己的实验代码，并使用 lein run 命令运行它们。

#### 自动插件反击了

你很快就会明白为什么这通常不是使用 origami 的最佳方式，因为这每次都会重新编译你所有的源文件。然而，这是一种可以用来检查所有代码编译和运行都没有错误的技术。

所以这里有一个关于如何为 Java、Scala 和 Kotlin 设置第 [1](1.html) 章中介绍的自动插件解决方案的快速提示，这次是针对 Clojure/Origami 代码。

修改 **project.clj** 文件以添加 lein-auto 插件，使其与以下代码匹配:

 **:plugins [[lein-gorilla "0.4.0"][lein-auto "0.1.3"]]**  :auto {:default {:file-pattern #"\.(clj)$"}}

默认情况下，这不在项目模板中，因为大多数时候可能不需要它。

一旦添加了这个，您就可以通过在想要执行的命令前面加上 auto 来运行通常的 auto 命令。这里:

lein auto run

这将执行主名称空间，并等待文件更改编译并再次执行。

因此，在修改了 **ok.clj** 文件的 main 方法后，如下所示:

(defn -main [& args]     (->      (imread "resources/cat.jpg")      (cvt-color! COLORMAP_JET)      (imwrite "jet-neko.jpg")      (println "A new jet neko has arisen!"))) You can see a new file jet-neko.jpg created and a new fun-looking cat, as in Figure [2-4](#Fig4).![img/459821_1_En_2_Fig4_HTML.jpg](Images/459821_1_En_2_Fig4_HTML.jpg) Figure 2-4

喷气猫

现在，虽然这个带有自动插件的设置非常好，但是让我们看看如何通过使用 Clojure REPL 来最小化代码输入和处理输出之间的延迟。

#### 在 REPL

我们刚刚回顾了如何以类似于 Java、Scala 和 Kotlin 的方式运行示例和编写一些 Origami 代码，并再次看到了如何包含和使用自动插件。

更好的是，Clojure 带有一个读取-评估-打印-循环(REPL)环境，这意味着你可以一行一行地输入代码，比如命令，然后立即执行。

为了启动 Clojure REPL，Leiningen 有一个名为 REPL 的子命令，可以用

lein repl

在终端/控制台上打印一些启动行之后:

nREPL server started on port 64044 on host 127.0.0.1 - nrepl://127.0.0.1:64044 REPL-y 0.3.7, nREPL 0.2.11 Clojure 1.8.0 Java HotSpot(TM) 64-Bit Server VM 1.8.0_151-b12     Docs: (doc function-name-here)           (find-doc "part-of-name-here")   Source: (source function-name-here)  Javadoc: (javadoc java-object-or-class-here)     Exit: Control+D or (exit) or (quit)  Results: Stored in vars *1, *2, *3, an exception in *e

然后，您将看到 REPL 提示:

opencv3.ok=>

opencv3.ok 是项目的主名称空间，您可以在提示符下键入代码，就像在 opencv3/ok.clj 文件中键入代码一样。例如，让我们通过打印版本来检查底层 OpenCV 库是否正确加载:

(println "Using OpenCV Version: " opencv3.core/VERSION "..") ; Using OpenCV Version:  3.3.1-dev ..

该库确实被正确加载，并且通过 Leiningen 的魔法找到了原生绑定。

让我们现在就开始吧。下面两行从 utils 名称空间获取一些函数，主要是打开一个框架，然后加载一个图像并将其打开到那个框架中:

(require '[opencv3.utils :as u]) (u/show (imread "resources/minicat.jpg")) The cute cat from Figure [2-5](#Fig5) should now be showing up on your computer as well.![img/459821_1_En_2_Fig5_HTML.jpg](Images/459821_1_En_2_Fig5_HTML.jpg) Figure 2-5

可爱的猫

折纸艺术鼓励图像处理管道的概念。因此，要读取图像，转换加载图像的颜色，并在一个帧中显示结果图像，您通常会使用 Clojure 线程宏-->，一个接一个地管道化所有的函数调用，就像下面的一行程序一样:

(-> "resources/minicat.jpg" imread (cvt-color! COLOR_RGB2GRAY) (u/show)) Which now converts the minicat.jpg from Figure [2-5](#Fig5) to its gray version as in Figure [2-6](#Fig6).![img/459821_1_En_2_Fig6_HTML.jpg](Images/459821_1_En_2_Fig6_HTML.jpg) Figure 2-6

灰色可爱的猫

->无非是重新组织代码，使第一个调用结果进入下一行的输入，依此类推。这使得图像处理代码非常快速和简洁。

请注意，这些行是直接执行的，所以您不必等待文件更改或任何事情，只需按 Enter 键就可以在屏幕上得到结果。

Instant gratification.

> 即时满足需要太长时间。
> 
> 凯丽·费雪

#### 原子公司的 REPL

Leiningen 开发的 REPL 相当不错，通过文档可以发现许多其他特性，但是它很难与标准文本编辑器提供的自动完成功能竞争。

使用来自 **project.clj** 文件的所有相同的项目元数据，Atom 编辑器实际上可以通过插件提供即时和可视化的完成选择。

The plug-in to install is named proto-repl. Effectively, you will need to install two plug-ins

*   prot-repl 所需的油墨插件

*   原始复制插件

to get the same setup on your atom editor, as shown in Figure [2-7](#Fig7).![img/459821_1_En_2_Fig7_HTML.jpg](Images/459821_1_En_2_Fig7_HTML.jpg) Figure 2-7

在 Atom 中安装两个插件:ink 和 proto-repl

The same Leiningen-based REPL can be started either by the atom menu as in Figure [2-8](#Fig8) or by the equivalent key shortcut.![img/459821_1_En_2_Fig8_HTML.jpg](Images/459821_1_En_2_Fig8_HTML.jpg) Figure 2-8

从 Atom 内部启动 REPL

启动 REPL 时，Atom 编辑器的右侧会打开一个名为 Proto-REPL 的窗口。这与您直接从终端执行 **lein repl** 命令时使用的 REPL 完全相同。所以，你也可以在那里输入代码。

But the real gem of this setup is to have autocompletion and choice presented to you when typing code, as in Figure [2-9](#Fig9).![img/459821_1_En_2_Fig9_HTML.jpg](Images/459821_1_En_2_Fig9_HTML.jpg) Figure 2-9

即时完成

You can now retype the code to read and convert the color of an image directly in a file , let’s say **ok.clj**. Your setup should now be similar to that shown in Figure [2-10](#Fig10).![img/459821_1_En_2_Fig10_HTML.jpg](Images/459821_1_En_2_Fig10_HTML.jpg) Figure 2-10

Atom 编辑器+ Clojure 代码

输入代码后，您可以使用 Ctrl-Alt+s(在 Mac 上，Command-Ctrl+s)来选择代码并执行选定的代码行。

您还可以通过使用 Ctrl-Alt+b(在 Mac 上，Command-Ctrl+b)来执行光标前的代码块，并获得即时满足感。

After code evaluation, and a slight tab arrangement, you can have instant code writing on the left-hand side, and the image transformation feedback on the right-hand side, just as in Figure [2-11](#Fig11).![img/459821_1_En_2_Fig11_HTML.jpg](Images/459821_1_En_2_Fig11_HTML.jpg) Figure 2-11

基于编辑器的理想计算机视觉环境

jet-set cat 现在显示在 output.jpg 文件中，可以通过在打开的编辑器选项卡中更新和执行代码来更新。

比如自己看看添加 **resize 时会发生什么！**处理流程中的函数调用，如下面的代码所示。

(->     (imread "resources/cat.jpg")     **(resize! (new-size 150 100))**     (cvt-color! COLORMAP_JET)     (imwrite "output.jpg"))

很好。一只新调整大小的喷气机猫现在立刻出现在你的屏幕上。

#### 大猩猩笔记本

为了完成这个食谱，让我们展示一下如何在一个折纸项目中使用 gorilla。

Gorilla 是一个 Leiningen 插件，你可以在其中编写和运行笔记本，就像 python 的 jupyter 一样。

这意味着你可以在编写文档的同时编写代码，更好的是，你还可以与外界分享这些笔记。

这是怎么回事？Gorilla 接受您的项目设置，并使用它在后台 REPL 中执行代码。因此，它将找到取自 **project.clj** 文件的 origami/opencv 设置。

它还将启动一个 web 服务器，其目标是提供笔记或工作表。工作表是您可以编写代码行并执行它们的页面。

您还可以在表单中以 markdown 标记的形式编写文档，该标记呈现为 HTML。

结果，每一个笔记，或者工作表，实际上都是一个迷你博客。

clj-opencv 模板附带的 **project.clj** 文件定义了一个方便的 leiningen 别名来通过笔记本别名启动 gorilla:

:aliases {"notebook" ["gorilla" ":ip" "0.0.0.0" ":port" "10000"]}

这有效地告诉 leiningen 将 **notebook** 子命令转换为下面的 gorilla 命令:

lein gorilla :ip 0.0.0.0 :port 10000

让我们通过在控制台或终端上使用以下命令来尝试一下:

lein notebook

几秒钟后，大猩猩 REPL 启动了。您可以在以下位置访问它:

http://localhost:10000/worksheet . html？filename=notes/practice.clj

You will be presented with a worksheet like in Figure [2-12](#Fig12).![img/459821_1_En_2_Fig12_HTML.jpg](Images/459821_1_En_2_Fig12_HTML.jpg) Figure 2-12

大猩猩笔记本和一只猫

In a gorilla notebook , every block of the page is either Clojure code or markdown text. You can turn the currently highlighted block to text mode by using Alt+g, Alt+m (or Ctrl+g, Ctrl+m on Mac) where m is for markdown, as in Figure [2-13](#Fig13).![img/459821_1_En_2_Fig13_HTML.jpg](Images/459821_1_En_2_Fig13_HTML.jpg) Figure 2-13

降价文本模式

You can also turn back the highlighted block into code mode by using Alt+g, Alt+j (or Ctrl+g, Ctrl+j on Mac), where j is for Clo**j**ure, as in Figure [2-14](#Fig14).![img/459821_1_En_2_Fig14_HTML.jpg](Images/459821_1_En_2_Fig14_HTML.jpg) Figure 2-14

代码块

To execute the highlighted block of code , you would use Shift+Enter, and the block turns into executed mode, as in Figure [2-15](#Fig15).![img/459821_1_En_2_Fig15_HTML.jpg](Images/459821_1_En_2_Fig15_HTML.jpg) Figure 2-15

Clojure 代码已执行

它所做的是从代码块中读取，通过 websocket 将输入发送到后台 REPL，检索结果，并将其打印到代码块的底层 div 中。

To make it easy to navigate a worksheet, the most used shortcuts have been gathered in Table [2-1](#Tab1).Table 2-1

大猩猩 REPL 最常用的快捷键

<colgroup class="calibre18"><col class="tcol"> <col class="tcol"> <col class="tcol"></colgroup> 
| 

快捷方式 Windows/Linux

 | 

快捷 Mac

 | 

使用

 |
| --- | --- | --- |
| -好的 | -好的 | 去上面的街区 |
| ↓ | ↓ | 去下面的街区 |
| Shift+Enter | Shift+Enter | 评估突出显示的块 |
| Alt+g，Alt+b | Ctrl+g， Ctrl+b | 在当前块之前插入块 |
| Alt+g，Alt+n | Ctrl+g， Ctrl+n | 在当前块旁边插入块 |
| Alt+g、Alt+u | Ctrl+g， Ctrl+u | 将当前块**上移**一个块 |
| Alt+g，Alt+d | Ctrl+g， Ctrl+d | 将当前块**向下**移动一个块 |
| Alt+g、Alt+x | Ctrl+g， Ctrl+x | **删除**当前块 |
| alt+空格 | ctrl+空格键 | 自动完成选项 |
| Alt+g， Alt+s | Ctrl+g，Ctrl+s | **保存**当前工作表 |
| Alt+g，Alt+l | Ctrl+g， Ctrl+l | **加载**一个工作表(一个文件) |
| Alt+g，Alt+e | Ctrl+g、Ctrl+e | 用新文件名保存当前工作表 |

好吧。现在你知道了在大猩猩 REPL 中开始输入代码所需要的一切。我们现在就来试试这个。在工作表的新代码块中，尝试键入以下 Clojure 代码。

(-> "http://eskipaper.cimg/jump-cat-1.jpg"  (u/mat-from-url)  (u/resize-by 0.3)  (u/mat-view)) And now… **Shift+Enter**! This should bring you close to Figure [2-16](#Fig16) and a new shot of instant gratification .![img/459821_1_En_2_Fig16_HTML.jpg](Images/459821_1_En_2_Fig16_HTML.jpg) Figure 2-16

瞬间跳跃猫

请记住，所有这些都发生在浏览器中，这有三个直接的积极后果。

第一个是远程人员实际上可以查看您的工作表，他们可以通过直接连接到 URL 直接从自己的机器上提供文档。

第二，他们也可以直接逐块执行代码，了解流程。

第三，工作表的保存格式使得它们可以用作标准名称空间，并且可以通过正常的代码编写工作流来使用。相反，这也意味着标准的 Clojure 文件可以打开，文档可以通过大猩猩 REPL 添加。

从现在开始，我们不会强制使用大猩猩 REPL 或 Atom 环境，甚至不会简单地在 REPL 上打字。实际上，这是同一个项目设置的三个不同视图。

现在只需记住，要显示一张图片，根据你是在大猩猩 REPL 还是在标准的 REPL，所用的函数会略有不同。

在大猩猩 REPL:

(u/mat-view)

在标准 REPL 中:

(u/show)

在 atom 中，您可以保存文件:

(imwrite mat “output.jpg”)

好吧，这次你真的准备好了！是时候学习一些计算机视觉基础知识了。

## 2.2 使用垫子

### 问题

正如你在第 [1](1.html) 章中所记得的，Mat 是你在使用 OpenCV 时最好的朋友。您还需要记住 new Mat()、setTo、copyTo 等函数来操作 Mat。现在，你想知道如何使用折纸库进行基本的 Mat 操作。

### 解决办法

因为 Origami 主要是 OpenCV 的包装器，所以所有相同的功能都存在于 API 中。这个菜谱再次展示了基本的 Mat 操作，并通过展示使用 Clojure 可能实现的代码技巧进一步展示了这些操作。

### 它是如何工作的

#### 创建垫子

记住你需要一个高度，一个宽度和一些通道来创建一个垫子。这是使用**新材料**功能完成的。下面的代码片段创建了一个 30×30 的 Mat，每个像素一个通道，每个值都是一个整数。

(def mat (new-mat 30 30 CV_8UC1)) If you try to display the content of the mat, either with u/mat-view (gorilla repl) or u/show (standard repl), then the memory assigned to the mat is actually left as is. See Figure [2-17](#Fig17).![img/459821_1_En_2_Fig17_HTML.jpg](Images/459821_1_En_2_Fig17_HTML.jpg) Figure 2-17

没有指定颜色的新垫子

让我们指定一种颜色，对垫子的每个像素都一样。这可以在创建垫子时完成，**或**可以通过**设置为**来完成，这是对**的调用。OpenCV 的 Java 函数 setTo** 。

(def mat (new-mat 30 30 CV_8UC1 (new-scalar 105))) ; or (def mat (new-mat 30 30 CV_8UC1)) (set-to mat (new-scalar 105)) Every pixel in the mat now has value 105 assigned to it (Figure [2-18](#Fig18)).![img/459821_1_En_2_Fig18_HTML.jpg](Images/459821_1_En_2_Fig18_HTML.jpg) Figure 2-18

指定颜色的垫子

为了理解 OpenCV 的大多数底层矩阵概念，使用**检查底层 mat 的值通常是一个好主意。转储**或简单的**转储。**

这将在本章中重复几次。要使用它，只需在您想要查看其内部的垫子上调用 dump。

(->>   (new-scalar 128.0)   (new-mat 3 3 CV_8UC1)   (dump))

预期的输出如下所示，mat 点的值都设置为 128。

[128 128 128] [128 128 128] [128 128 128]

。dump 调用原始的 OpenCV 函数，并将在一个字符串中打印所有的行和列像素值。

"[128, 128, 128;\n 128, 128, 128;\n 128, 128, 128]"

#### 制作彩色垫子

对于每个像素一个通道，您只能指定每个像素的白色强度，因此，您只能创建灰色垫。

要创建一个彩色垫，你需要三个通道，默认情况下，每个通道的值代表红色，蓝色和绿色的强度。

要创建一个 30×30 的红色 mat，下面的代码片段将创建一个空的三通道 mat，mat 中的每个点都设置为 RGB 值[255 0 0](是的，这是反转的，所以要小心):

(def red-mat    (new-mat 30 30 CV_8UC3 (new-scalar 0 0 255)))

以类似的方式，创建蓝色或绿色的垫子:

(def green-mat  (new-mat 30 30 CV_8UC3 (new-scalar 0 255 0))) (def blue-mat   (new-mat 30 30 CV_8UC3 (new-scalar 255 0 0))) If you execute all this in the gorilla REPL, each of the mats shows up, as in Figure [2-19](#Fig19).![img/459821_1_En_2_Fig19_HTML.jpg](Images/459821_1_En_2_Fig19_HTML.jpg) Figure 2-19

红色、绿色和蓝色垫子

#### 使用 Submat

你会记得我们已经在第 [1](1.html) 章看到了如何使用 submat 让我们回顾一下如何使用折纸来使用这些 submats。

这里，我们首先创建一个每个像素有三个通道的 RGB mat，并将所有像素设置为青色。

然后可以使用 **submat** 函数和一个矩形来定义 submat 的大小，从而创建一个 submat。

这给出了以下代码片段:

(def mat (new-mat 30 30 CV_8UC3 (new-scalar 255 255 0))) (def sub (submat mat (new-rect 10 10 10 10))) (set-to sub (new-scalar 0 255 255)) The resulting main mat, with yellow inside where the submat was defined, and the rest of the mat in cyan color, is shown in Figure [2-20](#Fig20).![img/459821_1_En_2_Fig20_HTML.jpg](Images/459821_1_En_2_Fig20_HTML.jpg) Figure 2-20

用折纸提交

在这个阶段，看看一行折纸代码能做什么，通过使用 **hconcat！**，一个将多个地垫连接在一起的函数，以及 **clojure.core/repeat** ，创建一个相同项目的序列。

(u/mat-view (hconcat! (clojure.core/repeat 10 mat3))) The resulting pattern is shown in Figure [2-21](#Fig21).![img/459821_1_En_2_Fig21_HTML.jpg](Images/459821_1_En_2_Fig21_HTML.jpg) Figure 2-21

折纸乐趣

至此，你已经可以自己琢磨出一些有创意的生成模式了。

#### 设置一种像素颜色

使用 **set-to** 设置垫子的所有颜色。使用 Java 方法 **put** 将一个像素设置为一种颜色。 **put** 函数获取 mat 中的一个位置，以及一个表示该像素的 RGB 值的字节数组。

因此，如果您想创建一个 3×3 的 mat，它的所有像素都是黄色的，您可以使用下面的代码片段。

(def yellow (byte-array [0 238 238])) (def a (new-mat 3 3 CV_8UC3)) (.put a 0 0 yellow) (.put a 0 1 yellow) (.put a 0 2 yellow) (.put a 1 0 yellow) (.put a 1 1 yellow) (.put a 1 2 yellow) (.put a 2 0 yellow) (.put a 2 1 yellow) (.put a 2 2 yellow)

遗憾的是，3×3 的 mat 对于这本书来说有点太小了，所以你应该自己输入代码。

转储函数在这里工作得很好，您可以在下面看到黄色 mat 的内容:

[0 238 238 0 238 238 0 238 238] [0 238 238 0 238 238 0 238 238] [0 238 238 0 238 238 0 238 238]

不过逐行输入这些内容有点累，所以这里需要使用 Clojure 代码根据需要遍历像素。

调用 Clojure core **doseq** 可以方便地减少样板文件。

(doseq [x [0 1 2]         y [0 1 2]]   (prn  "x=" x "; y=" y))

前面简单的 doseq 片段简单地遍历了一个 3×3 mat 的所有像素。

"x=" 0 "; y=" 0 "x=" 0 "; y=" 1 "x=" 0 "; y=" 2 "x=" 1 "; y=" 0 "x=" 1 "; y=" 1 ...

因此，为了更有趣一点，让我们为 100×100 彩色垫的每个像素显示一些随机的红色变体。手动操作会很累，所以我们在这里也使用 doseq 序列。

(def height 100) (def width 100) (def a (new-mat height width CV_8UC3)) (doseq [x (range width)         y (range height)]   (.put a x y (byte-array [0 0 (rand 255)]))) Figure [2-22](#Fig22) gives one version of the executed snippet.![img/459821_1_En_2_Fig22_HTML.jpg](Images/459821_1_En_2_Fig22_HTML.jpg) Figure 2-22

随机填充的红色像素变体垫子

#### 滚边工艺和一些生成艺术

您已经可以看到 Origami 是如何让生成性工作与 OpenCV mats 的集成变得非常简单和有趣的。

这一小段也将快速介绍折纸所鼓励的管道制作过程。

Clojure 有两个主要的构造(称为宏)，名为->和-> >他们**通过管道**在连续的函数调用中传递结果。

第一个函数调用的结果作为参数传递给第二个函数，然后第二个函数调用的结果传递给第三个函数，依此类推。

第一个宏-->，将结果作为第一个参数传递给下一个函数调用。

第二个宏--> >，将结果作为最后一个参数传递给下一个函数调用。

例如，可以通过以下方式创建随机灰色遮罩:

(->> (rand 255)      (double)      (new-scalar)      (new-mat 30 30 CV_8UC1)      (u/mat-view)) Which, read line by line, gives the following steps:

*   用 rand 生成随机值；该值介于 0 和 255 之间。

*   生成的值是一个 float，所以我们把这个值变成 double。

*   new-scalar 用于创建 OpenCV 可以方便处理的等效字节数组。

*   然后，我们创建一个新的 30×30 通道的 mat，并将标量传递给 new-mat 函数，以将 mat 的颜色设置为随机生成的值。

*   Finally, we can view the generated mat (Figure [2-23](#Fig23)).![img/459821_1_En_2_Fig23_HTML.jpg](Images/459821_1_En_2_Fig23_HTML.jpg) Figure 2-23

    生成随机灰色垫

你也可以用随机颜色的垫子做同样的事情。这次调用 rand 函数三次(图 [2-24](#Fig24) )。

(->> (new-scalar (rand 255) (rand 255) (rand 255))      (new-mat 30 30 CV_8UC3)      (u/mat-view))

或者，结果相同，但使用了更多的 Clojure 核心函数:

(->>  #(rand 255)  (repeatedly 3)  (apply new-scalar)  (new-mat 30 30 CV_8UC3)  (u/mat-view)) where

*   #创建一个匿名函数

*   重复调用前面的函数三次，以生成由三个随机值组成的数组

*   apply 使用数组作为新标量的参数

*   如您之前所见，new-mat 创建了一个垫子

*   u/mat-view displays the mat (Figure [2-24](#Fig24)) in the gorilla REPL![img/459821_1_En_2_Fig24_HTML.jpg](Images/459821_1_En_2_Fig24_HTML.jpg)

    图 2-24。

现在，您可以看到如何在这些迷你代码流的基础上构建不同的 mat 生成变体。你也可以组合那些垫子，当然是用 **hconcat！**或者 **vconcat！**OpenCV 的功能。

下面的新代码片段使用 range 生成一个 25 个元素的序列，然后通过缩放范围值在 0–255 的范围内创建灰色垫(图 [2-25](#Fig25) )。

 (->> (range 25)       (map #(new-mat 30 30 CV_8UC1 (new-scalar (double (* % 10)))))       (hconcat!)       (u/mat-view)) ![img/459821_1_En_2_Fig25_HTML.jpg](Images/459821_1_En_2_Fig25_HTML.jpg) Figure 2-25

25 个垫的灰色渐变

您还可以通过生成 255 个值的范围来使事情变得平滑，并使创建的垫子稍微小一些，每个垫子的大小为 2×10(图 [2-26](#Fig26) )。

(->> (range 255)      (map #(new-mat 20 2 CV_8UC1 (new-scalar (double %))))      (hconcat!)      (u/mat-view)) ![img/459821_1_En_2_Fig26_HTML.jpg](Images/459821_1_En_2_Fig26_HTML.jpg) Figure 2-26

255 色垫的平滑灰色渐变

## 2.3 装载、展示、保存地垫

### 问题

您已经看到了如何创建和生成地垫；现在您想要保存它们，重新打开它们，并打开位于 URL 中的 mats。

### 解决办法

Origami 包装了两个主要的 opencv 函数来与文件系统交互，即 imread 和 imwrite。

它还提供了一个名为 imshow 的新函数，如果您以前使用过标准 opencv，您可能会看到这个函数。这里将会更详细地介绍它。

最后，u/mat-from-url 是一个 origami 实用函数，它允许您检索托管在网络上的 mat。

### 它是如何工作的

#### 装货

imread 的工作方式与 opencv 完全相同；这主要意味着您只需给它一个来自文件系统的路径，文件就会被读取并转换成一个随时可用的 Mat 对象。

在最简单的形式中，可以像下面的简短代码片段那样加载图像:

(def mat (imread "resources/kitten.jpg"))

文件路径 **resources/kitten.jpg** 是相对于项目的，也可以是文件系统上的完整路径。

The resulting loaded Mat object is shown in Figure [2-27](#Fig27).![img/459821_1_En_2_Fig27_HTML.jpg](Images/459821_1_En_2_Fig27_HTML.jpg) Figure 2-27

“这不是猫。”

Following the opencv documentation, the following image file formats are currently supported by Origami :

*   Windows 位图*.bmp、*.dib

*   JPEG 文件- *。jpeg、*。jpg、*。jpe(日本)

*   便携式网络图形- *。png

*   sun grid-* . Sr、*.ras

The following are also usually supported by OpenCV but may not be supported on all platforms coming with Origami:

*   JPEG 2000 文件- *.jp2

*   webp。web 页

*   便携式图像格式- *。多溴联苯醚*。PGM . *。ppm(ppm)

*   TIFF 文件- *。tiff，*。标签图像文件格式。

加载图像时，可以参考表 [1-3](1.html#Tab3) 指定用于加载图像的选项，如灰度，同时调整大小。

要加载灰度并将图像大小调整为其大小的四分之一，您可以使用下面的代码片段，该代码片段是使用您刚刚看到的管道样式编写的。

(-> "resources/kitten.jpg"     (imread IMREAD_REDUCED_GRAYSCALE_4)     (u/mat-view)) It loads the same picture, but the mat looks different this time , as its color has been converted, like in Figure [2-28](#Fig28).![img/459821_1_En_2_Fig28_HTML.jpg](Images/459821_1_En_2_Fig28_HTML.jpg) Figure 2-28

“这不是灰猫。”

#### 节约

Origami 的 imwrite 函数取自 opencv 的 imwrite，但是颠倒了参数的顺序，使得该函数在处理管道时易于使用。

例如，要将先前加载的灰色猫写入一个新文件，您可以使用

(imwrite mat "grey-neko.png") A new file, **grey-neko.png** , will be created from the loaded mat object (Figure [2-29](#Fig29)).![img/459821_1_En_2_Fig29_HTML.jpg](Images/459821_1_En_2_Fig29_HTML.jpg) Figure 2-29

灰色 neko.png

您可以观察到生成的文件图像实际上已经从 jpg 转换为 png，只需在文件名中将其指定为扩展名。

更改参数顺序的原因是，在这种情况下，您可以从管道代码流中保存图像。

请参见下面在转换流程中图像是如何保存的。

(-> "resources/kitten.jpg"     (imread IMREAD_REDUCED_GRAYSCALE_4)     (imwrite "grey-neko.png")     (u/mat-view))

该垫将被保存在文件图像 grey-neko.png，并处理将继续到下一步，在这里垫查看。

#### 表演

Origami 提供了一种快速预览图像的方式，并以来自 opencv3.utils 名称空间的 **imshow** 函数的形式传输。

(-> "resources/kitten.jpg"     (imread)     (u/imshow)) The **imshow** function takes a mat as the parameter and opens a Java frame with the mat inside, as shown in Figure [2-30](#Fig30).![img/459821_1_En_2_Fig30_HTML.jpg](Images/459821_1_En_2_Fig30_HTML.jpg) Figure 2-30

被陷害的猫

The frame opened by **imshow** has a few default sets of key shortcuts, as shown in Table [2-2](#Tab2).Table 2-2

快速视图中的默认键

<colgroup class="calibre18"><col class="tcol"> <col class="tcol"></colgroup> 
| 

钥匙

 | 

行动

 |
| --- | --- |
| Q | 关闭框架 |
| F | 全屏边框；再次按下返回窗口模式 |
| S | 快速保存当前显示的图片 |

这还不是全部；当使用 **imshow** 来定义从框架的背景颜色到其大小等等的各种设置时，您可以传递一个贴图。此外，可以将处理程序部分添加到地图中，您可以在其中定义自己的快捷键。

请参见以下帧的配置图示例。

{:frame   {:color "#000000" :title "image" :width 400 :height 400}  :handlers   { 85 #(gamma! % 0.1) 86 #(gamma! % -0.1)}}

在**处理程序**部分，映射的每个条目都由一个 ASCII 键码和一个函数组成。该函数接受一个 mat，并且必须返回一个 mat。在这里，你可以假设伽玛！是根据亮度参数改变垫子亮度的功能。

Figure [2-31](#Fig31) shows the mat after pressing u.![img/459821_1_En_2_Fig31_HTML.jpg](Images/459821_1_En_2_Fig31_HTML.jpg) Figure 2-31

深色猫

Figure [2-32](#Fig32) shows the mat after pressing v.![img/459821_1_En_2_Fig32_HTML.jpg](Images/459821_1_En_2_Fig32_HTML.jpg) Figure 2-32

明亮的猫

这不是本书最重要的部分，但是在第 4 章中，快速帧在播放视频流时变得非常方便。

#### 从 URL 加载

虽然通常情况下可以从运行代码的文件系统访问图片，但是很多时候需要处理远程托管的图片。

Origami 提供了一个基本的 **mat-from-url** 函数，该函数获取一个 url 并将其转换为 OpenCV mat。

在 origami 中完成这项工作的标准方法如下面的代码片段所示:

(-> "http://www.hellonico.info/static/cat-peekaboo.jpg"     (u/mat-from-url)     (u/mat-view)) And the resulting image is shown in Figure [2-33](#Fig33).![img/459821_1_En_2_Fig33_HTML.jpg](Images/459821_1_En_2_Fig33_HTML.jpg) Figure 2-33

来自互联网的猫

直到最近，这还是加载图片的唯一方式。但是，大多数时候，你会做一些像

(-> "http://www.hellonico.info/static/cat-peekaboo.jpg"     (u/mat-from-url)     **(u/resize-by 0.5)**     (u/mat-view))

加载图片后立即调整其大小。现在，u/mat-from-url 也接受 imread 参数。因此，要加载灰色的远程图片，并减小它的大小，可以直接传入 IMREAD_*参数。注意，这有在文件系统上创建临时文件的副作用。

(-> "http://www.hellonico.info/static/cat-peekaboo.jpg"     (u/mat-from-url IMREAD_REDUCED_GRAYSCALE_4)     (u/mat-view)) The same remote picture is now both smaller and loaded in black and white, as shown in Figure [2-34](#Fig34).![img/459821_1_En_2_Fig34_HTML.jpg](Images/459821_1_En_2_Fig34_HTML.jpg) Figure 2-34

黑白猫归来

## 2.4 使用颜色、色彩映射表和色彩空间

> 颜色是我们大脑和宇宙相遇的地方。
> 
> 保罗·克莱尔

### 问题

您想学习更多关于如何在 OpenCV 中处理颜色的知识。到目前为止，我们只看到了使用 RGB 编码的颜色。肯定还有！

### 解决办法

Origami 提供了两个简单的名称空间，opencv3.colors.rgb 和 opencv3.colors.rgb，来创建用于基本着色的标量值，因此我们将首先回顾如何使用这两个名称空间来将颜色设置为 mat。

颜色贴图的工作原理类似于颜色过滤器，根据您的心情，您可以使垫子变得更红或更蓝。

**应用-颜色-贴图！**和**变身！**是用来实现颜色切换的两个 opencv 核心函数。

最后，cvt-color！是另一个核心 opencv 函数，它将一个 mat 从一个颜色空间带到另一个颜色空间，例如从 RGB 到黑白。这是 OpenCV 的一个重要的关键特性，因为大多数识别算法不能在标准 RGB 中正确使用。

### 它是如何工作的

#### 简单的颜色

需要来自 origami 包的颜色，因此当您使用它们时，需要更新笔记本顶部的名称空间声明。

(ns joyful-leaves    (:require     [opencv3.utils :as u]     **[opencv3.colors.html :as html]**     **[opencv3.colors.rgb :as rgb]**     [opencv3.core :refer :all]))

使用名称空间 rgb，您可以为 RGB 值创建标量，而不是猜测它们。

So, if you want to use a red color , you can get your environment to help you find and autocomplete the scalar you are looking for, as shown in Figure [2-35](#Fig35).![img/459821_1_En_2_Fig35_HTML.jpg](Images/459821_1_En_2_Fig35_HTML.jpg) Figure 2-35

颜色

因此，在实际应用中，您确实可以使用下面的代码片段来创建一个 20×20 的红色垫子。

(-> (new-mat 20 20 CV_8UC3 rgb/red-2)     (u/mat-view ))

请注意，由于 rgb/red-2 是一个标量，您可以通过打印来转储每个通道的值:

#object[org.opencv.core.Scalar 0x4e73ed0 "[0.0, 0.0, 205.0, 0.0]"]

这是很好的快速找到颜色代码。

创建了**opencv3.colors.html**名称空间，以便您也可以使用 css 中使用的传统十六进制符号。对于一个漂亮的浅绿色带一点蓝色，你可以用这个:

(html/->scalar "#66cc77")

在全样本模式下，使用线程--> >，这将给出

(->> (html/->scalar "#66cc77")      (new-mat 20 20 CV_8UC3 )      (u/mat-view )) which creates a small mat of a light green/blue color (Figure [2-36](#Fig36)).![img/459821_1_En_2_Fig36_HTML.jpg](Images/459821_1_En_2_Fig36_HTML.jpg) Figure 2-36

使用 HTML 代码的颜色

打印颜色本身会为您提供指定的 RGB 值:

(html/->scalar "#66cc77") ; "[119.0, 204.0, 102.0, 0.0]"

你确实可以通过自己创建 RGB 标量来检查颜色是否匹配。

(->> (new-scalar 119 204 102)      (new-mat 20 20 CV_8UC3 ))

这将给你一个具有完全相同的基于 RGB 的颜色的垫子。

#### 彩色地图

使用简单的滤镜，通过简单的颜色变化就可以理解彩色地图，这与您最喜欢的智能手机照片应用程序类似。

有一些默认的地图可以和 OpenCV 一起使用；让我们尝试其中的一种，比如 COLORMAP_AUTUMN，它将垫子变成了一种相当秋天的红色。

To apply the map to a Mat, for example the cat from Figure [2-37](#Fig37), simply use the apply-color-map! function .![img/459821_1_En_2_Fig37_HTML.jpg](Images/459821_1_En_2_Fig37_HTML.jpg) Figure 2-37

要上色的猫

下面的代码片段显示了如何依次使用通常的 imread 和 apply-color-map。

(-> "resources/cat-on-sofa.jpg"     (imread IMREAD_REDUCED_COLOR_4)     (apply-color-map! COLORMAP_AUTUMN)     (u/mat-view)) The resulting cat is shown in Figure [2-38](#Fig38).![img/459821_1_En_2_Fig38_HTML.jpg](Images/459821_1_En_2_Fig38_HTML.jpg) Figure 2-38

秋猫

Here is the full list of standard color maps available straight out of the box; try them out!

*   COLORMAP_HOT

*   COLORMAP_HSV

*   COLORMAP_JET

*   色彩映射表 _ 骨骼

*   COLORMAP_COOL

*   COLORMAP_PINK(彩色贴图 _ 粉红色)

*   COLORMAP_RAINBOW(彩虹色)

*   COLORMAP_OCEAN

*   COLORMAP_WINTER

*   COLORMAP_SUMMER(颜色映射 _ 夏天)

*   colormap _ 秋季

*   COLORMAP_SPRING

您也可以定义自己的色彩空间转换。这是通过矩阵乘法来完成的，这听起来很怪，但实际上比听起来简单。

我们将以 rgb/yellow-2 为例。你可能不记得了，所以如果你把它打印出来，你会发现这实际上被编码为，没有蓝色，一些绿色，一些红色，翻译成 RGB 给出如下:[0 238 238]。

然后，我们定义一个由三列三行组成的变换矩阵；由于我们使用的是 RGB 色板，因此我们将在三通道模式下执行此操作。

[0 0 0]     ; blue [0 0.5 0]   ; green [0 1 0.5]   ; red

这个矩阵是做什么的？请记住，我们希望对每个像素应用颜色转换，这意味着在输出中，我们希望每个像素都有一组 RGB 值。

For any given pixel , the new RGB values are such that

*   蓝色为 0 ×输入蓝色+ 0 ×输入绿色+ 0 ×输入红色

*   绿色为 0 ×输入蓝色+ 0.5 ×输入绿色+ 0 ×输入红色

*   红色为 0 ×输入蓝色+ 1 ×输入绿色+ 0.5 输入红色

因此，由于我们的垫子都是黄色的，我们有以下输入:

[0 238 238]

并且每个像素的输出如下:

[0x0 + 0x238 + 0x238, 0x0 + 0.5x238 + 0 x 238, 0x0 + 1x238 + 0.5x238]

或者，由于 255 是通道的最大值:

[0 119 255]

在折纸代码中，给出了以下内容:

(def custom   (u/matrix-to-mat [   [0 0 0]          ; blue   [0 0.5 0]        ; green   [0 1 0.5]        ; red   ])) (-> (new-mat 3 3 CV_8UC3 rgb/yellow-2)     (dump))

这里，mat 内容与 dump 一起显示:

[0 238 238 0 238 238 0 238 238] [0 238 238 0 238 238 0 238 238] [0 238 238 0 238 238 0 238 238]

然后:

(-> (new-mat 30 30 CV_8UC3 rgb/yellow-2) u/mat-view) (-> (new-mat 3 3 CV_8UC3 rgb/yellow-2)     (transform! custom)     (dump))

转换的结果如下所示，如预期的那样由[0 119 255]个值的矩阵组成。

[0 119 255 0 119 255 0 119 255] [0 119 255 0 119 255 0 119 255] [0 119 255 0 119 255 0 119 255] (-> (new-mat 30 30 CV_8UC3 rgb/yellow-2)     (transform! custom)     u/mat-view)

确保一个接一个地执行语句，以查看输出中不同的 RGB 值，以及彩色垫。

你可以在文献中寻找，但一个好的棕褐色转换将使用以下矩阵:

(def sepia-2 (u/matrix-to-mat [   [0.131 0.534 0.272]   [0.168 0.686 0.349]   [0.189 0.769 0.393]])) (-> "resources/cat-on-sofa.jpg"    (imread IMREAD_REDUCED_COLOR_4)    (transform! sepia-2) (u/mat-view )) With the resulting sepia cat in Figure [2-39](#Fig39).![img/459821_1_En_2_Fig39_HTML.jpg](Images/459821_1_En_2_Fig39_HTML.jpg) Figure 2-39

棕褐色猫

是时候出去制作自己的过滤器了！

我们已经看到了如何将变换应用于 RGB 中的每个像素。稍后，当切换到其他色彩空间时，您也可以记住，即使这些值不再是红色、蓝色、绿色，这个**变换！**功能仍然可以以同样的方式使用。

#### 彩色空间

到目前为止，你一直在 RGB 色彩空间中工作，这是最简单的一种。在大多数计算情况下，RGB 不是最有效的，因此过去已经创建了许多其他颜色空间，可供使用。对于折纸，要从一个切换到另一个，通常使用函数 cvt-color！

色彩空间开关有什么作用？

这基本上意味着每个像素的三个通道值具有不同的含义。

例如，RGB 中的红色可以在 RGB 中编码为 0 0 238(其图形表示如图 [2-40](#Fig40) ):

(-> (new-mat 1 1 CV_8UC3 rgb/red-2)     (.dump)) ; "[  0,   0, 238]" (-> (new-mat 30 30 CV_8UC3 rgb/red-2)     (u/mat-view)) ![img/459821_1_En_2_Fig40_HTML.jpg](Images/459821_1_En_2_Fig40_HTML.jpg) Figure 2-40

RGB 颜色空间中的红色

但是，当您更改颜色空间并将其转换到另一个名称空间时，比如 HSV，Hue-Saturation-Value，矩阵的值会发生变化。

(-> (new-mat 1 1 CV_8UC3 rgb/red-2)     (cvt-color! COLOR_RGB2HSV)     (.dump)) (-> (new-mat 30 30 CV_8UC3 rgb/red-2)     (cvt-color! COLOR_RGB2HSV)     (u/mat-view)) And of course, the simple display of the mat content is not really relevant anymore; as shown in Figure [2-41](#Fig41), it turned to yellow!!![img/459821_1_En_2_Fig41_HTML.jpg](Images/459821_1_En_2_Fig41_HTML.jpg) Figure 2-41

HSV 颜色空间中的红色

改变色彩空间并不意味着改变垫子的颜色，而是改变这些颜色在内部的表现方式。

你为什么想要改变色彩空间？

虽然每种颜色空间都有自己的优点，但是颜色空间 HSV 被广泛使用，因为它很容易使用范围来识别和找到垫中给定颜色的形状。

如你所知，在 RGB 中，每个通道的每个值代表红色、绿色或蓝色的强度。

在 opencv 术语中，假设我们希望看到红色的线性级数；我们可以增加或减少绿色和蓝色这两个通道的值。

(->> (range 255)      (map #(new-mat 20 1 CV_8UC3 (new-scalar % % 255)))      (hconcat!)      (u/mat-view)) That shows the line of Figure [2-42](#Fig42).![img/459821_1_En_2_Fig42_HTML.jpg](Images/459821_1_En_2_Fig42_HTML.jpg) Figure 2-42

RGB 中红色的线性强度

但是，如果在一张图片中，我们试图寻找橙色的形状呢？嗯…那个橙色在 RGB 下看起来怎么样？

是的，它开始变得有点困难。让我们采取不同的方法，看看 HSV 颜色空间。

As mentioned, HSV stands for Hue-Saturation-Value :

*   Hue 就是你所理解的颜色:它通常是 0 到 360 之间的值，代表 360 度，即使我们使用最多的 OpenCV 八位图片实际上使用的范围是 0 到 180，或者一半。

*   饱和度是灰度的数量，它的范围在 0 到 255 之间。

*   Value 代表亮度，范围在 0 到 255 之间。

在这种情况下，让我们看看会发生什么，如果我们自己画这个，用我们到目前为止学到的东西。

函数 **hsv-mat** 从一个色调值创建一个 mat。

正如你所看到的，代码切换了两次色板的颜色空间，一次是将颜色空间设置为 HSV 并设置色调，然后返回到 RGB，这样我们就可以稍后用常用函数 **imshow** 或 **mat-view** 来绘制它。

(defn hsv-mat [h]   (let[m (new-mat 20 3 CV_8UC3)]     (cvt-color! m COLOR_BGR2HSV)     (set-to m (new-scalar h 255 255))     (cvt-color! m COLOR_HSV2BGR)     m))

我们已经在 OpenCV 中看到了从 0 到 180 的色调范围，所以让我们在它上面做一个范围，并用 **hconcat** 创建一个所有小垫子的连接垫子。

(->> (range 180)      (map hsv-mat)      (hconcat!)      (u/mat-view)) The drawn result is shown in Figure [2-43](#Fig43).![img/459821_1_En_2_Fig43_HTML.jpg](Images/459821_1_En_2_Fig43_HTML.jpg) Figure 2-43

色调值

首先，您可能会注意到，在条形的末尾，颜色又变回红色。因此，它通常被认为是圆柱体。

你可能注意到的第二件事是，通过提供一个范围，可以更容易地分辨出你要找的颜色。例如，20-25 通常用于黄色。

Because it can be annoying to select red in one range, you can sometimes use the reverse RGB during the color conversion: instead of using COLOR_BGR2HSV, you can try to use COLOR_RGB2HSV (Figure [2-44](#Fig44)).![img/459821_1_En_2_Fig44_HTML.jpg](Images/459821_1_En_2_Fig44_HTML.jpg) Figure 2-44

倒置色调光谱

这样更容易选择红色，色调范围在 105 到 150 之间。

让我们在一只红色的猫身上试试。在自然界很难找到一只红色的猫，所以我们用一张图来代替。

猫加载了下面的代码片段(图 [2-45](#Fig45) )。

(-> "resources/redcat.jpg"     (imread IMREAD_REDUCED_COLOR_2)     (u/mat-view)) ![img/459821_1_En_2_Fig45_HTML.jpg](Images/459821_1_En_2_Fig45_HTML.jpg) Figure 2-45

天然红猫

然后，我们定义一个范围的下红和上红。剩余的饱和度和值被设置为 30 30(有时 50 50)和 255 255(有时 250 250)，因此从非常暗和灰色到完全成熟的色调颜色。

(def lower-red  (new-scalar 105 30 30)) (def upper-red  (new-scalar 150 255 255))

现在，我们使用 opencv 的范围内函数，我们将在后面的配方 2-7 中再次看到，说我们想在指定的范围内找到颜色，并将结果存储在一个蒙版中，该蒙版被初始化为一个空的 mat。

(def mask (new-mat)) (-> "resources/redcat.jpg"     (imread IMREAD_REDUCED_COLOR_2)     (cvt-color! COLOR_RGB2HSV)     (in-range lower-red upper-red mask)) (u/mat-view mask) Et voila: the resulting mask mat is in Figure [2-46](#Fig46).![img/459821_1_En_2_Fig46_HTML.jpg](Images/459821_1_En_2_Fig46_HTML.jpg) Figure 2-46

图片中红色的遮罩

我们将在后面看到寻找颜色技术的更多细节，但是现在你明白为什么你想要把颜色空间从 RGB 转换到更容易处理的东西，这里还是 HSV。

## 2.5 旋转和变换垫子

> 我现在要回想一下，天体的运动是圆周运动，因为球体的运动是圆周旋转。
> 
> 尼古拉斯·哥白尼

### 问题

你想开始旋转垫和应用简单的线性变换。

### 解决办法

OpenCV 中有三种实现旋转的方法。

在非常简单的情况下，您可以简单地使用 flip，它将水平、垂直或同时水平和垂直翻转图片。

另一种方法是使用旋转函数，这是一个简单的函数，基本上只取一个方向常数，并根据该常数旋转垫子。

全明星的方式是使用函数 warp-affine。使用它可以做更多的事情，但是要掌握它稍微困难一些，需要利用矩阵计算来执行转换。

让我们看看这一切是如何运作的！

### 它是如何工作的

我们将在整个教程中使用一个基础图像，所以现在就开始加载它以供进一步参考(图 [2-47](#Fig47) )。当然，是的，在这个阶段你已经可以加载你自己的了。

(def neko (imread "resources/ai3.jpg" IMREAD_REDUCED_COLOR_8)) (u/mat-view neko) ![img/459821_1_En_2_Fig47_HTML.jpg](Images/459821_1_En_2_Fig47_HTML.jpg) Figure 2-47

小猫准备翻转和旋转

#### 轻弹

好吧。这一个相当容易。你只需要在图像上调用 flip，用一个参数告诉你想要怎样翻转。

请注意在图像处理流程中第一次使用**克隆**。

一边翻转！在适当的位置进行变换，从而修改传递给它的图片，克隆创建一个新的垫子，因此原始的 neko 保持不变。

(->  neko      (clone)      (flip! 0)      (u/mat-view)) And the result is shown in Figure [2-48](#Fig48).![img/459821_1_En_2_Fig48_HTML.jpg](Images/459821_1_En_2_Fig48_HTML.jpg) Figure 2-48

翻转的猫

大多数折纸功能都是这样工作的。标准版，这里是 flip，需要一个输入垫和一个输出垫，而 flip！就地转换，只需要一个输入/输出垫。还有，虽然 flip 没有返回值，但是 flip！返回输出 mat，以便在管道中使用。

同样的，你已经看过 cvt-color 了，还有 cvt-color！，还是 hconcat 和 hconcat！，等等。

让我们用 Clojure 玩一会儿，用一个序列显示垫子上所有可能的翻转。

(->> [1 -1 0]      (map #(-> neko clone (flip! %)))      (hconcat!)      (u/mat-view)) This time, all the flips are showing (Figure [2-49](#Fig49)).![img/459821_1_En_2_Fig49_HTML.jpg](Images/459821_1_En_2_Fig49_HTML.jpg) Figure 2-49

触发器

#### 循环

功能**旋转！**也采用一个旋转参数，并根据它旋转图像。

(->  neko      (clone)      (rotate! ROTATE_90_CLOCKWISE)      (u/mat-view)) Note again the use of clone to create an intermediate mat in the processing flow, and the result in Figure [2-50](#Fig50).![img/459821_1_En_2_Fig50_HTML.jpg](Images/459821_1_En_2_Fig50_HTML.jpg) Figure 2-50

顺时针旋转的猫

还要注意如何使用 clone 和--> >从一个源创建多个垫子。

(->> [ROTATE_90_COUNTERCLOCKWISE ROTATE_90_CLOCKWISE]      (map #(-> neko clone (rotate! %)))      (hconcat!)      (u/mat-view)) In the final step, the multiple mats are concatenated using **hconcat!** (Figure [2-51](#Fig51)) or **vconcat!** (Figure [2-52](#Fig52)).![img/459821_1_En_2_Fig51_HTML.jpg](Images/459821_1_En_2_Fig51_HTML.jpg) Figure 2-51

使用 hconcat！在旋转垫上

![img/459821_1_En_2_Fig52_HTML.jpg](Images/459821_1_En_2_Fig52_HTML.jpg) Figure 2-52

使用 vconcat！在旋转垫上

由于使用了 clone，原来的垫子保持不变，仍然可以在其他加工管道中使用，就像刚刚装载一样。

#### 弯曲

最后一个，正如承诺的，是稍微复杂一点的版本，使用 opencv 函数 **warp-** **affine** 和旋转矩阵来旋转图片。

The rotation matrix is created using the function get-rotation-matrix-2-d and three parameters:

*   一个旋转点，

*   旋转角度，

*   缩放值。

在第一个例子中，我们将缩放因子设为 1，旋转角度为 45 度。

我们还将旋转点作为原始垫子的中心。

(def img (clone neko)) (def rotation-angle 45) (def zoom 1) (def matrix   (get-rotation-matrix-2-d     (new-point (/ (.width img) 2) (/ (.height img) 2))     rotation-angle     zoom))

**matrix** 也是一个 2×3 的 Mat，由浮点值组成，打印出来就可以看到。然后，旋转矩阵可以传递给扭曲函数。Warp 还需要一个尺寸来创建具有适当尺寸的最终垫子。

(warp-affine! img matrix (.size img)) (u/mat-view img) And the 45-degrees-rotated cat is shown in Figure [2-53](#Fig53).![img/459821_1_En_2_Fig53_HTML.jpg](Images/459821_1_En_2_Fig53_HTML.jpg) Figure 2-53

45 度

现在让我们用一些自动生成技术来增加一些乐趣。让我们创建一个垫子，它由旋转的猫的多个垫子串联而成，每个猫以不同的旋转因子旋转。

为此，让我们创建一个函数 **rotate-by！** **，**使用 get-rotation-matrix-2d 获取图像和角度，并在内部应用旋转

(defn rotate-by! [img angle]   (let [M2    (get-rotation-matrix-2-d       (new-point (/ (.width img) 2) (/ (.height img) 2)) angle 1)]     (warp-affine! img M2 (.size img))))

然后，您可以在小型管道中使用该函数。管道采用 0 到 360°之间的旋转范围，并按顺序将每个角度应用于原始 neko 垫。

(->> (range 0 360 40)      (map #(-> neko clone (rotate-by! % )))      (hconcat!)      (u/mat-view)) And the fun concatenated mats are shown in Figure [2-54](#Fig54).![img/459821_1_En_2_Fig54_HTML.jpg](Images/459821_1_En_2_Fig54_HTML.jpg) Figure 2-54

范围和旋转

此外，让我们增强轮换！函数还可以使用可选的缩放参数。如果未指定缩放因子，其值默认为 1。

(defn rotate-by!   ([img angle] (rotate-by! img angle 1))   ([img angle zoom]    (let      [M2        (get-rotation-matrix-2-d           (new-point (/ (.width img) 2) (/ (.height img) 2)) angle zoom)]     (warp-affine! img M2 (.size img)))))

然后，zoom 参数被传递给 get-rotation-matrix-2d 函数。

这一次，该代码片段只是在七个随机缩放值上做了一个范围。

(->> (range 7)      (map (fn[_] (-> neko clone (rotate-by! 0 (rand 5)))))      (hconcat!)      (u/mat-view)) And the result is shown in Figure [2-55](#Fig55). Also note that when the zoom value is too small, default black borders can be seen in the resulting small mat.![img/459821_1_En_2_Fig55_HTML.jpg](Images/459821_1_En_2_Fig55_HTML.jpg) Figure 2-55

七只随机缩放的猫

同样，许多其他图像变换也可以使用 warp-affine 来完成，方法是传递使用 get-affine-transform、get-perspective-transform 等变换矩阵创建的矩阵。

大多数转换采用点的源矩阵和点的目标矩阵，并且每个 opencv get-**函数创建一个转换矩阵，以相应地从一组点映射到其他点。

当 OpenCV 需要一个“东西”的 mat 时，您可以使用 util 包中的 origami 构造函数 matrix-to-matofxxx。

(def src   (u/matrix-to-matofpoint2f [[0 0]                              [5 5]                              [4 6]])) (def dst   (u/matrix-to-matofpoint2f [[2 0]                              [5 5]                              [4 6]])) (def transform-mat (get-affine-transform src dst))

应用变换的方式与扭曲仿射相同。

(-> neko clone (warp-affine! transform-mat (.size neko)) u/mat-view) Figure [2-56](#Fig56) shows the result of the affine transformation .![img/459821_1_En_2_Fig56_HTML.jpg](Images/459821_1_En_2_Fig56_HTML.jpg) Figure 2-56

猫仿射变换

## 2.6 过滤垫

### 问题

与形状变形和点移动的 mat 变换相反，过滤对原始 mat 的每个像素应用一个操作。

这个食谱是关于了解不同的过滤方法。

### 解决办法

在这个食谱中，我们将首先看看如何创建和应用手动滤镜，通过手动改变每个像素的值。

由于这很无聊，我们将继续使用**乘法！**通过应用每个通道值的系数来有效地改变垫子的颜色和亮度。

接下来，我们将使用 **filter-2-d，**进行一些实验，该实验用于将定制的滤镜应用于垫子。

该菜谱将以如何使用**阈值**和**自适应阈值**来在 mat 中仅保留部分信息的例子来结束。

### 它是如何工作的

#### 手动过滤器

第一个示例是一个函数，它将三通道图片中除一个通道值之外的所有通道值都设置为 0。这具有完全改变垫子颜色的效果。

请注意该函数如何在内部创建 mat 中所有字节的完全有序的字节数组。此处使用 3 是因为我们假设我们正在使用由每个像素三个通道组成的 mat。

(defn filter-buffer! [image _mod]   (let [ total (* 3 (.total image))          bytes (byte-array total)]          (.get image 0 0 bytes)          (doseq [^int i (range 0 total)]          **(if (not (= 0 (mod (+ i _mod) 3)))**            **(aset-byte bytes i 0)))**         (.put image 0 0 bytes)         image))

mod if 语句实现了这一点，因此我们为 mat 中的所有像素将该通道的所有值都设置为 0。

We then use a new cat picture (Figure [2-57](#Fig57)).![img/459821_1_En_2_Fig57_HTML.jpg](Images/459821_1_En_2_Fig57_HTML.jpg) Figure 2-57

美丽的法国猫

只需将我们的功能付诸行动。参数中的值 0 意味着除了蓝色通道之外的所有通道都将被设置为 0。

(->   "resources/emilie1.jpg"   (imread)   **(filter-buffer! 0)**   (u/mat-view)) And yes, the resulting picture is overly blue (Figure [2-58](#Fig58)).![img/459821_1_En_2_Fig58_HTML.jpg](Images/459821_1_En_2_Fig58_HTML.jpg) Figure 2-58

蓝猫

在这里，我们再次使用 Clojure 代码生成功能，在通道范围内创建所有三个 mat 的串联 mat(图 [2-59](#Fig59) )。

(def source     (imread "resources/emilie1.jpg")) (->> (range 0 3)      (map #(filter-buffer! (clone source) %))      (hconcat!)      (u/mat-view)) ![img/459821_1_En_2_Fig59_HTML.jpg](Images/459821_1_En_2_Fig59_HTML.jpg) Figure 2-59

三只猫

#### 乘；成倍增加；（使）繁殖

手动创建一个过滤器来查看其过滤器如何工作的细节是很好的，但实际上，OpenCV 有一个名为 **multiply** 的函数已经为你完成了所有这些工作**。**

该函数使用 origami 的 mat-to-mat-of-double 创建的 mat 对像素中每个通道的值进行乘法运算。

So, in an RGB-encoded picture, using matrix [1.0 0.5 0.0] means that

*   蓝色通道将保持原样；蓝色通道值将乘以 1.0

*   绿色通道值将减半；其值将乘以 0.5

*   红色通道值将被设置为 0；其值将乘以 0。

将此直接付诸行动，我们使用下面的简短片段将白猫变成醇厚的蓝色图片(图 [2-60](#Fig60) )。

(->   "resources/emilie1.jpg"   (imread)   (multiply! (u/matrix-to-mat-of-double [ [1.0 0.5 0.0]] ))   (u/mat-view)) ![img/459821_1_En_2_Fig60_HTML.jpg](Images/459821_1_En_2_Fig60_HTML.jpg) Figure 2-60

醇厚的猫

#### 光度

结合您在第 [2](2.html) 章中已经学到的关于更改通道的知识，您可能会记得，虽然 RGB 在更改特定颜色通道的强度方面非常出色，但在 HSV 颜色空间中更改亮度值也很容易。

这里，我们再次使用 OpenCV 的乘法函数，但是这一次，mat 的颜色空间在乘法之前被改变为 HSV。

(->   "resources/emilie1.jpg"   (imread)   **(cvt-color! COLOR_BGR2HSV)**   (multiply! (u/matrix-to-mat-of-double [ [1.0 1.0 **1.5**]] ))   **(cvt-color! COLOR_HSV2RGB)** (u/mat-view)) Note how the matrix used with multiply only applies a 1.5 factor to the third channel of each pixel, which in the HSV color space is indeed the luminosity . A bright result is shown in Figure [2-61](#Fig61).![img/459821_1_En_2_Fig61_HTML.jpg](Images/459821_1_En_2_Fig61_HTML.jpg) Figure 2-61

明亮的猫

#### 高光

前面的小片段实际上为您提供了一种突出 mat 中的元素的好方法。假设你创建了一个 submat，或者你可以通过一些寻找形状的算法来访问它；您可以应用发光度效果来仅高亮显示整个垫子的该部分。

This is what the following new snippet does:

*   它将主 mat 加载到 img 变量中

*   它创建了一个处理流水线，专注于 img 的一个子表

*   颜色转换和乘法运算仅在 submat 上完成

 (def img (->   "resources/emilie1.jpg"   (imread))) (-> img   (submat (new-rect 100 50 100 100))   (cvt-color! COLOR_RGB2HLS)   (multiply! (u/matrix-to-mat-of-double [ [1.0 1.3 1.3]] ))   (cvt-color! COLOR_HLS2RGB)) (u/mat-view img) The resulting highlight mat is shown in Figure [2-62](#Fig62).![img/459821_1_En_2_Fig62_HTML.jpg](Images/459821_1_En_2_Fig62_HTML.jpg) Figure 2-62

猫脸

#### 过滤器 2d

**filter-2d****，**这里介绍的新 OpenCV 函数，也是对字节进行运算的。但是这一次，它根据 src 像素的值和周围像素的值来计算目标 mat 的每个像素的值。

为了理解什么都不做是怎么可能的，让我们举一个例子，通过应用将当前像素的值乘以 1 的过滤器，乘法保持像素的值不变，并忽略其邻居的值。对于这种效果，3×3 滤镜矩阵在中心(目标像素)的值为 1，在所有其他像素(周围的相邻像素)的值为 0。

(-> "resources/emilie4.jpg"     (imread)     (filter-2-d! -1 (u/matrix-to-mat       [[0 0 0]        [0 1 0]        [0 0 0]]))     (u/mat-view)) This does nothing! Great. We all want more of that. The filter-2-d function call really just keeps the image as is, as shown in Figure [2-63](#Fig63).![img/459821_1_En_2_Fig63_HTML.jpg](Images/459821_1_En_2_Fig63_HTML.jpg) Figure 2-63

未受干扰的猫

让我们回到矩阵和原始像素值上来，通过一个简单的灰色矩阵的例子，更好地理解事情是如何进行的。

(def m (new-mat 100 100 CV_8UC1 (new-scalar 200.0))) The preceding snippet, as you know by now, creates a small 100×100 gray mat (Figure [2-64](#Fig64)).![img/459821_1_En_2_Fig64_HTML.jpg](Images/459821_1_En_2_Fig64_HTML.jpg) Figure 2-64

灰色垫子

现在，我们将使用 submat 来关注灰色贴图的一部分，并仅在 submat 上应用 filter-2d 函数。

我们采用 3×3 矩阵进行运算，并对主中心像素使用 0.3 的值。这意味着当我们应用滤镜时，目标矩阵中对应像素的值将是 200×0.25=50。

(def s (submat m (new-rect 10 10 50 50))) (filter-2-d! s -1     (u/matrix-to-mat       [[0 0 0]        [0 0.25 0]        [0 0 0]])) Here, that means the entire submat will be darker than the pixels not located in the submat, as confirmed in Figure [2-65](#Fig65).![img/459821_1_En_2_Fig65_HTML.jpg](Images/459821_1_En_2_Fig65_HTML.jpg) Figure 2-65

Submat 已更改

如果您在一个小得多的 mat 上查看像素值本身，您会看到中心像素(submat)的值被正好除以 4。

(def m (new-mat 3 3 CV_8UC1 (new-scalar 200.0))) (def s (submat m (new-rect 1 1 1 1))) (filter-2-d! s -1 (u/matrix-to-mat       [[0 0 0]        [0 0.25 0]        [0 0 0]])) (dump m) ;  [200 200 200] ;  [200  50 200] ;  [200 200 200]

你还能用 filter-2-d 做什么？它也可以用于艺术效果；您可以使用自定义值创建自己的过滤器。所以，继续尝试吧。

(-> "resources/emilie4.jpg"     (imread)     (filter-2-d! -1 (u/matrix-to-mat      [[17.8824    -43.5161     4.11935]       [ -3.45565    27.1554    -3.86714]       [ 0.0299566   0.184309   -1.46709]]))     (bitwise-not!)     (u/mat-view)) The preceding filter turns the cat image into a mat ready to receive some brushes of watercolors (Figure [2-66](#Fig66)).![img/459821_1_En_2_Fig66_HTML.jpg](Images/459821_1_En_2_Fig66_HTML.jpg) Figure 2-66

巧妙的猫

#### 阈值

阈值是另一种过滤技术，当 mat 中的值最初高于或低于阈值时，它会将这些值重置为默认值。

呃，你说什么？

为了理解这是如何工作的，让我们回到一个像素级的小垫子，一个简单的 3×3 垫子。

(u/matrix-to-mat [[0 50 100] [100 150 200] [200 210 250]]) ; [0,   50,  100 ;  100, 150, 200 ;  200, 210, 250] We can apply a threshold that sets the value of a pixel to

*   0，如果原始像素低于 150

*   250 否则

这是如何工作的。

(->   (u/matrix-to-mat [[0 50 100] [100 150 200] [200 210 250]])   (threshold! 150 250 THRESH_BINARY)   (.dump))

得到的矩阵是

[0,   0,   0  0,   0,   250  250, 250, 250]

如您所见，只有值大于 150 的像素被保留为非零值。

您可以使用 THRESH_BINARY_INV 创建互补矩阵，如下所示。

(->   (u/matrix-to-mat [[0 50 100] [100 150 200] [200 210 250]])   (threshold! 150 250 THRESH_BINARY_INV)   (.dump)) ; [250, 250, 250    250, 250,   0      0,   0,   0]

现在，将这种技术应用到一张图片上，只留下垫子内容的有趣形状，使事情变得非常有趣。

(-> "resources/emilie4.jpg"   (imread)   (cvt-color! COLOR_BGR2GRAY)   (threshold! 150 250 THRESH_BINARY_INV)   (u/mat-view)) Figure [2-67](#Fig67) shows the resulting mat after applying the threshold to my sister’s white cat.![img/459821_1_En_2_Fig67_HTML.jpg](Images/459821_1_En_2_Fig67_HTML.jpg) Figure 2-67

阈值猫

作为参考，也是为了下一章的冒险，还有另一个名为 adaptive-threshold 的方法，它根据周围像素的值来计算目标值。

(-> "resources/emilie4.jpg"   (imread)   (u/resize-by 0.07)   (cvt-color! COLOR_BGR2GRAY)   **(adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY 9 20)**   (u/mat-view))

*   如果验证了阈值，则结果值为 255。

*   你刚刚看到了 THRESH_BINARY 或 THRESH_BINARY_INV

*   9 是要考虑的邻近区域的大小

*   20 是从总和中减去的值

Figure [2-68](#Fig68) shows the result of the adaptive threshold.![img/459821_1_En_2_Fig68_HTML.jpg](Images/459821_1_En_2_Fig68_HTML.jpg) Figure 2-68

适应性猫

自适应阈值通常在配方 2-8 中与模糊技术一起使用，我们将很快研究它。

## 2.7 应用简单的掩蔽技术

### 问题

遮罩可以用在各种情况下，在这些情况下，您只想将遮罩功能应用到遮罩的某个部分。

你想知道如何创造面具，如何将它们付诸行动。

### 解决办法

我们将再次回顾使用范围内的来创建基于颜色的蒙版。

然后，我们将使用 **copy-to** 和 **bitwise-** 在主贴图上应用函数，但只在蒙版选择的像素上。

### 它是如何工作的

让我们从从花园里采摘一朵浪漫的玫瑰并装载 imread 开始。

(def rose   (-> "resources/red_rose.jpg"       (imread IMREAD_REDUCED_COLOR_2))) (u/mat-view rose) Figure [2-69](#Fig69) shows the flower that will be the source of this exercise.![img/459821_1_En_2_Fig69_HTML.jpg](Images/459821_1_En_2_Fig69_HTML.jpg) Figure 2-69

玫瑰

为了搜索颜色，正如我们已经看到的，让我们首先将玫瑰转换到一个不同的颜色空间。

你现在知道如何实现这一点了。因为我们要寻找的颜色是红色，所以让我们从 RGB 转换到 HSV。

(def hsv   (-> rose clone (cvt-color! COLOR_RGB2HSV))) (u/mat-view hsv) ![img/459821_1_En_2_Fig70_HTML.jpg](Images/459821_1_En_2_Fig70_HTML.jpg) Figure 2-70

HSV 色彩空间中的玫瑰

然后让我们过滤红色，因为玫瑰也有点暗，让我们在下限红色上设置低的饱和度和亮度值。

(def lower-red  (new-scalar 120 30 15)) (def upper-red (new-scalar 130 255 255)) (def mask (new-mat)) (in-range hsv lower-red upper-red mask) (u/mat-view mask)

我们在配方 2-4 中使用了这种方法，但是我们忘记看一下创建的蒙版。基本上，遮罩是一个与范围内输入大小相同的 mat，当源像素不在范围内时，像素设置为 0，当源像素在范围内时，像素设置为 1。事实上，在这里，范围内的工作有点像一个阈值。

The resulting mask is shown in Figure [2-71](#Fig71).![img/459821_1_En_2_Fig71_HTML.jpg](Images/459821_1_En_2_Fig71_HTML.jpg) Figure 2-71

红玫瑰的面具

掩码现在可以和**一起使用了！**原始源上升，因此我们只复制蒙版 mat 值不等于 0 的像素。

(def res (new-mat)) (bitwise-and! rose res mask) (u/mat-view res) And now you have a resulting mat (Figure [2-72](#Fig72)) of only the red part of the picture.![img/459821_1_En_2_Fig72_HTML.jpg](Images/459821_1_En_2_Fig72_HTML.jpg) Figure 2-72

只有玫瑰

作为一个小练习，我们将使用 convert-to 来更改 mat 的亮度，并对每个像素应用以下公式:

原始*alpha+ beta

因此，下面的代码片段只是通过调用 convert-to 来实现这一点。

(def res2 (new-mat)) (convert-to res res2 -1 1 100) (u/mat-view res2) The resulting masked rose is a slightly brighter version of the original rose (Figure [2-73](#Fig73)).![img/459821_1_En_2_Fig73_HTML.jpg](Images/459821_1_En_2_Fig73_HTML.jpg) Figure 2-73

明亮的玫瑰

让我们把产生的亮玫瑰复制回原图，或者是它的复制品(图 [2-74](#Fig74) )。

(def cl (clone rose)) (copy-to res2 cl mask) (u/mat-view cl) ![img/459821_1_En_2_Fig74_HTML.jpg](Images/459821_1_En_2_Fig74_HTML.jpg) Figure 2-74

走到一起

这些概念很好地融合在一起。

最后，让我们尝试一些不同的东西，例如，复制一个完全不同的垫代替玫瑰，再次使用面具。

我们可以重用在前面创建的遮罩，并以类似的方式使用 copy-to 来仅复制某个贴图的特定点。

为了执行复制，我们需要 copy-to 中的源和目标具有完全相同的大小，以及掩码。如果不是这样的话，你会得到一个非常糟糕的错误。

第一步是调整垫子的大小。

(def cl2   (imread "resources/emilie1.jpg")) (resize! cl2 (new-size (cols mask) (rows mask)))

然后，在原始 rose 图片的克隆上，我们可以执行复制，将 mask 指定为 copy-to 的最后一个参数。

(def cl3   (clone rose)) (copy-to cl2 cl3 mask) (u/mat-view cl3) The cat mat is thus copied onto the rose, but only where the mask allows the copy to happen (Figure [2-75](#Fig75)).![img/459821_1_En_2_Fig75_HTML.jpg](Images/459821_1_En_2_Fig75_HTML.jpg) Figure 2-75

猫和玫瑰

## 2.8 模糊图像

> *我屈服于自己想要模糊和融合艺术与生活之间界限的倾向[…]*
> 
> 利亚冰

### 问题

正如所承诺的，这是一个审查模糊技术的食谱。模糊化是一种简单而常用的技巧，可用于各种场合。

你想看看不同种类的模糊可用，以及如何使用折纸。

### 解决办法

OpenCV 中的模糊主要有四种方法: [**模糊**](http://docs.opencv.org/modules/imgproc/doc/filtering.html?highlight=blur#blur) 、 [**高斯模糊**](http://docs.opencv.org/modules/imgproc/doc/filtering.html?highlight=gaussianblur#gaussianblur) 、 [**中值模糊**](http://docs.opencv.org/modules/imgproc/doc/filtering.html?highlight=medianblur#medianblur) 、 [**双边过滤**](http://docs.opencv.org/modules/imgproc/doc/filtering.html?highlight=bilateralfilter#bilateralfilter) 。

让我们逐一回顾一下。

### 它是如何工作的

像往常一样，让我们加载一个基本的猫图片，以便在整个练习中使用。

(def neko   (-> "resources/emilie5.jpg"       (imread)       (u/resize-by 0.07))) (u/mat-view neko) Figure [2-76](#Fig76) shows another picture of my sister’s cat.![img/459821_1_En_2_Fig76_HTML.jpg](Images/459821_1_En_2_Fig76_HTML.jpg) Figure 2-76

猫在床上

#### 简单模糊和中间模糊

应用简单的**模糊**的流程相对简单。像许多其他图像处理技术一样，我们使用内核，一个主像素位于中心的正方形矩阵，比如 3×3 或 5×5。核是矩阵，其中每个像素被赋予一个系数。

在其最简单的形式中，我们只需要给它一个区域的内核大小来考虑模糊:内核区域越大，得到的图片就越模糊。

基本上，输出的每个像素是其核邻居的平均值。

(-> neko     (clone)     (blur! (new-size 3 3))     (u/mat-view)) The result can be seen in Figure [2-77](#Fig77).![img/459821_1_En_2_Fig77_HTML.jpg](Images/459821_1_En_2_Fig77_HTML.jpg) Figure 2-77

床上的模糊猫

而且内核越大，画面会越模糊。

图 [2-78](#Fig78) 显示了使用模糊功能的不同内核大小的结果。

(->> (range 3 10 2)      (map #(-> neko  clone (u/resize-by 0.5) (blur! (new-size % %))))      (hconcat!)      (u/mat-view)) ![img/459821_1_En_2_Fig78_HTML.jpg](Images/459821_1_En_2_Fig78_HTML.jpg) Figure 2-78

更大的内核

#### 高斯模糊

这种类型的模糊赋予内核中心更多的权重。我们将在下一章看到这一点，但这种类型的模糊实际上很好地消除了图片中的额外噪声。

(-> neko clone (gaussian-blur! (new-size 5 5) 17) (u/mat-view)) The result of the gaussian blur is shown in Figure [2-79](#Fig79).![img/459821_1_En_2_Fig79_HTML.jpg](Images/459821_1_En_2_Fig79_HTML.jpg) Figure 2-79

高斯模糊猫

#### 双边过滤器

当您想要平滑图片，但同时又想保留边缘时，可以使用这些滤镜。

什么是边缘？边缘是定义图片中可用形状的轮廓。

第一个例子展示了双边过滤器的简单用法。

(-> neko     clone     (bilateral-filter! 9 9 7)     (u/mat-view)) ![img/459821_1_En_2_Fig80_HTML.jpg](Images/459821_1_En_2_Fig80_HTML.jpg) Figure 2-80

高斯模糊

第二个例子展示了一个我们想要保留边缘的例子。使用著名的 opencv 函数 canny 可以很容易地找到边缘。我们将在下一章花更多的时间和 canny 在一起。

现在，让我们关注图 [2-81](#Fig81) 的输出和线条。

(-> neko     clone     (cvt-color! COLOR_BGR2GRAY)     (bilateral-filter! 9 9 7)     (canny! 50.0 250.0 3 true)     (bitwise-not!)     (u/mat-view)) ![img/459821_1_En_2_Fig81_HTML.jpg](Images/459821_1_En_2_Fig81_HTML.jpg) Figure 2-81

高斯模糊和精明

第三个例子快速展示了为什么你想使用双边过滤器，而不是简单的模糊。我们保持同样的小处理管道，但这次使用简单的模糊，而不是双边过滤器。

    (-> neko       clone       (cvt-color! COLOR_BGR2GRAY)       (blur! (new-size 3 3))       (canny! 50.0 250.0 3 true)       (bitwise-not!)       (u/mat-view)) The output clearly highlights the problem: defining lines have disappeared, and Figure [2-82](#Fig82) shows a disappearing cat …![img/459821_1_En_2_Fig82_HTML.jpg](Images/459821_1_En_2_Fig82_HTML.jpg) Figure 2-82

台词和猫都消失了！

#### 中值模糊

中间模糊是简单模糊的朋友。

(-> neko     clone     (median-blur! 27)     (u/mat-view))

值得注意的是，在内核长度较高的情况下，或者内核长度大于 21 的情况下，我们得到的东西更有艺术性。

It is less useful for shape detection, as seen in Figures [2-83](#Fig83) and [2-84](#Fig84), but still combines with other mats for creative impact, as we will see in chapter [3](3.html).![img/459821_1_En_2_Fig83_HTML.jpg](Images/459821_1_En_2_Fig83_HTML.jpg) Figure 2-83

艺术猫(内核长度 31)

![img/459821_1_En_2_Fig84_HTML.jpg](Images/459821_1_En_2_Fig84_HTML.jpg) Figure 2-84

使用内核 7 的中值模糊使线条消失

瞧啊。第 2 章介绍了 Origami 及其易用性:设置、简洁性、处理管道和各种转换。

This is only the beginning. Chapter [3](3.html) will be taking this setup to the next level by combining principles and functions of OpenCV to find shapes, count things, and move specific parts of mats to other locations.

> 未来属于今天为它做准备的人。
> 
> 马尔科姆·Ⅹ