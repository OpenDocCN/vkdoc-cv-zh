© Nicolas Modrzyk 2018 Nicolas ModrzykJava Image Processing Recipes[https://doi.org/10.1007/978-1-4842-3465-5_3](https://doi.org/10.1007/978-1-4842-3465-5_3)

# 3.成像技术

Nicolas Modrzyk<sup class="calibre11">[1](#Aff2) </sup> (1)Tokyo, Japan  

> 最完美的技巧是根本不会被注意到的。
> 
> 帕布罗·卡萨尔斯

前一章介绍了折纸以及如何在简单的垫子和图像上进行单步处理操作。

虽然这已经很好地展示了该库的易用性，但第三章希望通过将简单的处理步骤结合起来，向更大的目标迈进一步。从执行内容分析、轮廓检测、形状发现和形状移动，一直到基于计算机的素描和景观艺术，只要你能想到的，这里都有许多冒险等待着你。

我们将从熟悉的地方开始，通过在字节级操作 OpenCV mats，更详细地掌握图像操作的细节。

学习将分为两大部分。首先将是一个稍微侧重于艺术的部分，在这里我们用线条、渐变和 OpenCV 函数从现有的图像中创建新的图像。你将会使用已知的 origami/opencv 函数，但是一些其他的函数也将会根据需要引入到创作流程中。

这是折纸术最初的计划之一，用来创作图画。碰巧的是，为了理解简单的概念是如何组合在一起的，我不得不玩图像合成和线框，它们实际上比我想象的要好。更重要的是，添加你自己的风格并在以后重复使用这些作品是很容易的。所以第一部分是为了分享这个经验。

然后，在第二部分，我们将转移到更侧重于图像处理的技术。在回顾了来自艺术部门的即时反馈后，处理步骤在那个阶段将更容易掌握。

OpenCV 中的处理步骤大部分时间都很简单，但是 C++中的原始样本使得阅读指针行变得相当困难。我个人发现，即使包括 Clojure 学习曲线，Origami 也是一种更容易开始使用 OpenCV 的方法:您可以专注于代码行的直接影响，并尝试以不同的方式编写每一步，而不必每次都通过获得即时反馈来重新开始，直到它最终很好地到位。希望这一章的第二部分会让你足够舒服，你会想去挑战这些例子。

请注意，线性阅读本章可能是一个好主意，这样您就不会错过新功能或新技巧。然而，当然，没有什么能阻止你跳进你喜欢的地方。它毕竟是一本食谱！

## 3.1 玩颜色

### 问题

在前一章中，你已经看到了改变垫子颜色的各种技术。

你想要控制如何指定和影响颜色，例如，通过在垫子上应用特定的因素或功能来增加或减少它们的强度。

### 解决办法

在这里，您将了解以下内容:如何组合操作，如使用已知的 cvt-color 转换图像颜色通道；如何使用其他 OpenCV 函数像 **threshold** 来限制通道值；如何创建遮罩并使用功能**设置为**；以及如何使用函数来组合不同版本的 mat。

您还将更详细地回顾如何使用**变换！**创建基本艺术效果的功能。

### 它是如何工作的

为了玩垫子，我们将使用另一套猫和花，但是你当然可以随时尝试在你自己的照片上应用这些功能。

本章的名称空间头，以及所有的名称空间依赖项，将使用上一章中所需的相同名称空间，即 opencv3.core 和 opencv3.utils 以及来自 origami 的 opencv3 原始名称空间的 opencv3.colors.rgb。

所需的部分类似于下面的代码片段。

 (ns opencv3.chapter03  (:require   [opencv3.core :refer :all]   [opencv3.colors.rgb :as rgb]   [opencv3.utils :as u]))

通常为每个实验创建一个新的笔记本，并分别保存它们是一个好主意。

#### 在彩色垫上应用阈值

回到基础。您还记得如何在 mat 上设置阈值，并且只保留矩阵中大于 150 的值吗？

是的，你是正确的:使用阈值函数。

(-> (u/matrix-to-mat [[100 255 200]                       [100 255 200]                       [100 255 200]])     (threshold! 150 255 THRESH_BINARY)     (dump))

输入矩阵包含各种值，有些低于阈值 150，有些高于阈值 150。应用阈值时，下面的值设置为 0，上面的值设置为阈值的第二个参数值 255。

这导致了以下矩阵(图 [3-1](#Fig1) ):

[0 255 255] [0 255 255] [0 255 255]

这是一个单通道的垫子，但如果我们在三通道垫子上做同样的事情会怎么样呢？

(-> (u/matrix-to-mat [[0 0 170]                       [0 0 170]                       [100 100 0]])     (cvt-color! COLOR_GRAY2BGR)     (threshold! 150 255 THRESH_BINARY)     (dump))

将颜色转换为 BGR 会将单通道贴图的每个值复制为同一像素上的相同三个值。

之后立即应用 OpenCV 阈值函数，将阈值应用于每个通道上的所有值。因此得到的 mat 丢失了原始 mat 的 100 个值，只保留了 255 个值。

[0 0 0 0 0 0 255 255 255] [0 0 0 0 0 0 255 255 255] [0 0 0 0 0 0 0 0 0]

一个 3×3 的矩阵太小了，不能在屏幕上显示，所以让我们先在输入矩阵上使用 resize。

(-> (u/matrix-to-mat [[0 0 170]                       [0 0 170]                       [100 100 0]])     (cvt-color! COLOR_GRAY2BGR)     (resize! (new-size 50 50) 1 1 INTER_AREA)     (u/mat-view)) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig1_HTML.jpg](Images/459821_1_En_3_Fig1_HTML.jpg) Figure 3-1

黑白垫子

对前面的遮罩应用类似的阈值会保持浅灰色，浅灰色的值高于阈值，但会通过将深灰色变为黑色来移除深灰色。

(-> (u/matrix-to-mat [[0 0 170]                       [0 0 170]                       [100 100 0]])         (cvt-color! COLOR_GRAY2BGR)     (threshold! 150 255 THRESH_BINARY)     (resize! (new-size 50 50) 0 0 INTER_AREA)     (u/mat-view)) This gives us Figure [3-2](#Fig2).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig2_HTML.jpg](Images/459821_1_En_3_Fig2_HTML.jpg) Figure 3-2

阈值！

请注意，resize、 **INTER_AREA、**使用了一个特定的插值参数，它很好地清晰地切割了形状，而不是插值和强制模糊。

Just for some extra info, the default resize method gives something like Figure [3-3](#Fig3), which can be used in other circumstances , but this is not what we want here.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig3_HTML.jpg](Images/459821_1_En_3_Fig3_HTML.jpg) Figure 3-3

使用默认插值调整大小

无论如何，回到这个练习，你可能已经做到了:应用一个标准的阈值来推动鲜艳的颜色。

让我们看看它是如何在一个从图像加载的垫子上工作的，让我们加载该章节的第一个图像(图 [3-4](#Fig4) )。

(def rose   (imread "resources/chapter03/rose.jpg" IMREAD_REDUCED_COLOR_4)) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig4_HTML.jpg](Images/459821_1_En_3_Fig4_HTML.jpg) Figure 3-4

有人说爱是一条河

我们首先应用从矩阵加载的 mat 上应用的相同阈值，但这次是在 rose 图像上。

(->   original   (clone)   (threshold! 100 255 THRESH_BINARY)     (u/mat-view)) You get a striking result! (Figure [3-5](#Fig5))![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig5_HTML.jpg](Images/459821_1_En_3_Fig5_HTML.jpg) Figure 3-5

鲜艳的颜色

在一张拍得很好的照片中，这实际上给了你一种艺术感，你可以在此基础上制作卡片和圣诞礼物！

现在让我们在一个完全不同的图像上应用类似的技术。我们先把图片转成黑白，看看效果如何。

这次的图片是贪玩的小猫，如图 [3-6](#Fig6) 所示。

 (-> "resources/chapter03/ai6.jpg"     (imread IMREAD_REDUCED_COLOR_2)     (u/mat-view)) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig6_HTML.jpg](Images/459821_1_En_3_Fig6_HTML.jpg) Figure 3-6

顽皮的猫

如果你应用一个相似的阈值，但是在灰度版本上，会发生一些有趣的事情。

(-> "resources/chapter03/ai6.jpg"   (imread  IMREAD_REDUCED_GRAYSCALE_2)   (threshold! 100 255 THRESH_BINARY)   (u/mat-view)) The two cats are actually standing out and being highlighted (Figure [3-7](#Fig7)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig7_HTML.jpg](Images/459821_1_En_3_Fig7_HTML.jpg) Figure 3-7

顽皮、突出的猫

爽；这意味着我们想要突出的形状已经被突出显示。

类似这样的东西可以用来找出形状和移动的物体；更多信息请见配方 3-6 和 3-7。

现在，为了保持事物的艺术性，让我们开发一个小函数，将低于给定阈值的所有颜色转换为一种颜色，将高于阈值的所有值转换为另一种颜色。

We can achieve this by

*   首先，转向不同的颜色空间，即 HSV

*   从应用了 THRESH_BINARY 设置的阈值创建遮罩

*   从应用了 THRESH_BINARY_INV 设置的阈值创建第二个掩码，从而创建与第一个掩码具有相反值的掩码

*   将两个遮罩转换为灰色，因此它们仅由一个通道组成

*   使用 set-to 设置工作垫的颜色，遵循第一个遮罩

*   再次使用设置来设置工作垫的颜色，但是遵循第二个遮罩

*   就是这样！

在编码快乐时，我们将创建一个**低-高！**执行上述算法的函数。

**低-高！**功能由 cvt-color 组成！、threshold 和 set-to，所有的函数你都已经见过了。

(defn low-high!   ([image t1 color1 color2 ]   (let [_copy (-> image clone (cvt-color! COLOR_BGR2HSV))         _work (clone image)         _thresh-1 (new-mat)         _thresh-2 (new-mat)]     (threshold _copy _thresh-1 t1 255 THRESH_BINARY)     (cvt-color! _thresh-1 COLOR_BGR2GRAY)     (set-to _work color1 _thresh-1)     (threshold _copy _thresh-2 t1 255 THRESH_BINARY_INV)     (cvt-color! _thresh-2 COLOR_BGR2GRAY)     (set-to _work color2 _thresh-2)     _work)))

我们将在玫瑰图上调用它，阈值为 150，白烟到浅蓝色分裂。

(->  (imread "resources/chapter02/rose.jpg" IMREAD_REDUCED_COLOR_4)  (low-high! 150 rgb/white-smoke- rgb/lightblue-1)  (u/mat-view)) Executing the preceding snippet gives us Figure [3-8](#Fig8).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig8_HTML.jpg](Images/459821_1_En_3_Fig8_HTML.jpg) Figure 3-8

浅蓝色玫瑰上的白色

太好了。但是，你会问，我们真的需要为此创建两个遮罩吗？事实上，你不知道。你可以在第一个遮罩上完美地进行位元运算。为此，只需注释掉第二个遮罩创建并使用**位非！**第二次调用 set-to 之前。

    ;(threshold _copy _thresh-2 t1 255 THRESH_BINARY_INV)     ;(cvt-color! _thresh-2 COLOR_BGR2GRAY)     (set-to _work color2 (bitwise-not! _thresh-1))

在此基础上，您还可以对不同的颜色映射应用阈值，或者创建用作阈值的范围。

很明显，这里的另一个想法是对任何图片进行热空间皇后化。

如果你想知道，下面的代码片段可以帮你做到。

(def freddie-red (new-scalar 26 48 231)) (def freddie-blue (new-scalar 132 46 71)) (def bryan-yellow (new-scalar 56 235 255)) (def bryan-grey (new-scalar 186 185 181)) (def john-blue (new-scalar 235 169 0)) (def john-red (new-scalar 32 87 233)) (def roger-green (new-scalar 72 157 53)) (def roger-pink (new-scalar 151 95 226)) (defn queen-ize [mat thresh]     (vconcat! [     (hconcat!      [(-> mat clone (low-high! thresh freddie-red freddie-blue))       (-> mat clone (low-high! thresh john-blue john-red))])     (hconcat!      [(-> mat clone (low-high! thresh roger-pink roger-green ))       (-> mat clone (low-high! thresh bryan-yellow bryan-grey))] )]))

这真的是叫低-高！四次，每次都是 1982 年皇后乐队专辑 *Hot Space* 中的颜色。

And the old-fashioned result is shown in Figure [3-9](#Fig9).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig9_HTML.jpg](Images/459821_1_En_3_Fig9_HTML.jpg) Figure 3-9

猫和皇后

> *你真会设置* *的情绪*
> 
> *你真的进入了最佳状态*
> 
> *时尚弄潮儿*
> 
> 女王——“时尚弄潮儿”

#### 手动通道

每当你要处理一个垫子的通道时，记住 opencv **split** 函数。该功能将通道分隔在一系列独立的垫子中，因此您可以完全只关注其中一个。

然后，您可以将变换应用到该特定的 mat，而不触及其他 mat，完成后，您可以使用 **merge** 函数返回到多通道 mat，该函数执行相反的操作，获取一个 mat 列表，每个通道一个，并创建一个目标 mat，将所有通道合并到一个 mat 中。

为了看到这一点，假设你有一个简单的橙色垫子(图 [3-10](#Fig10) )。

(def orange-mat   (new-mat 3 3 CV_8UC3 rgb/orange-2)) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig10_HTML.jpg](Images/459821_1_En_3_Fig10_HTML.jpg) Figure 3-10

橙色 mat

如果你想把橙色的垫子变成红色的，你只需要把绿色通道的所有值都设置为 0。

所以，你从把 RGB 通道分成三个垫子开始；然后，将第二个 mat 的所有值设置为 0，并将所有三个 mat 合并为一个。

首先，让我们把垫子分成几个通道，看看每个通道的内容。

在快乐编码中，这给出了

(def channels (new-arraylist)) (split orange-mat channels)

这三个频道现在被分成列表中的三个元素。只需使用 dump 就可以查看每个频道的内容。

例如，转储蓝色通道:

(dump (nth channels 0)) ; no blue ;[0 0 0] ;[0 0 0] ;[0 0 0]

或者转储绿色通道:

(dump (nth channels 1)) ; quite a bit of green ;[154 154 154] ;[154 154 154] ;[154 154 154]

最后，转储红色通道:

(dump (nth channels 2)) ; almost max of red ;[238 238 238] ;[238 238 238] ;[238 238 238]

接下来，让我们将绿色通道中的所有 154 个值都变为 0。

(set-to (nth channels 1) (new-scalar 0.0))

然后，让我们将所有不同的垫子合并成一个垫子，得到图 [3-11](#Fig11) 。

(merge channels red-mat) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig11_HTML.jpg](Images/459821_1_En_3_Fig11_HTML.jpg) Figure 3-11

红马特

mat 中所有像素上的绿色强度都统一设置为 0，因此所有蓝色通道值都已设置为 0，结果 mat 是一个完全红色的 mat。

我们可以将这个小练习的所有不同步骤结合起来，创建函数 **update-channel！，**它接受一个 mat、一个函数和应用该函数的通道，然后返回结果 mat。

让我们尝试使用 **u/mat-to-bytes** 和 **u/bytes-to-mat 的第一个版本！**在 mat 和 byte 数组之间来回转换。

这变得很复杂，但实际上是我能想到的解释转换流程的最简单的版本。

The code flow will be as follows:

*   将频道分成一个列表

*   检索目标通道的 mat

*   将 mat 转换为字节

*   将该函数应用于通道模板的每个字节

*   将字节数组转换回 mat

*   将 mat 设置到列表中相应频道

*   将通道合并到生成的垫子中

现在，至少应该按如下顺序阅读:

(defn update-channel! [mat fnc chan]   (let [ channels (new-arraylist)]     (split mat channels)     (let [       old-ch (nth channels chan)       new-ch     (u/bytes-to-mat!       (new-mat (.height mat) (.width mat) (.type old-ch) )        (byte-array (map fnc (u/mat-to-bytes old-ch) )))]      (.set channels chan new-ch)      (merge channels mat)      mat)))

现在让我们回到我姐姐的猫，它已经在沙发上睡了一段时间了。是时候逗逗他，叫醒他了。

(def my-sister-cat    (-> "resources/chapter03/emilie1.jpg" (imread IMREAD_REDUCED_COLOR_8)))

在更新频道的帮助下！函数，让我们将所有的蓝色和绿色通道值转换为它们的最大可能值 255。我们本来可以编写一个同时应用多个函数的函数，但是现在让我们一个接一个地调用同一个函数。

(->    my-sister-cat    clone    (update-channel! (fn [x] 255) 1)    (update-channel! (fn [x] 255) 0) u/mat-view) This is not very useful as far as imaging goes, nor very useful for my sister’s cat either, but by maxing out all the values of the blue and green channels, we get a picture that is all cyan (Figure [3-12](#Fig12)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig12_HTML.jpg](Images/459821_1_En_3_Fig12_HTML.jpg) Figure 3-12

青色 cat

这个新创建的函数也可以与转换色彩空间结合使用。

因此，在调用 **update-channel 之前切换到 HSV 色彩空间！**让您完全控制垫子的颜色。

(->    my-sister-cat    clone   (cvt-color! COLOR_RGB2HSV)   (update-channel! (fn [x] 10) 0) ; blue filter   (cvt-color! COLOR_HSV2RGB)   (u/mat-view))

前面的代码应用蓝色滤镜，保持饱和度和亮度不变，从而仍然保持图像的动态。

当然，您可以尝试使用粉红色滤镜，将滤镜的值设置为 150，或者红色滤镜，将滤镜的值设置为 120 或任何其他可能的值。试试吧！

For now, enjoy the blue variation in Figure [3-13](#Fig13).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig13_HTML.jpg](Images/459821_1_En_3_Fig13_HTML.jpg) Figure 3-13

蓝滤猫

就个人而言，我也喜欢 YUV 开关与最大化所有亮度值(Y)相结合。

(->    my-sister-cat    clone   (cvt-color! COLOR_BGR2YUV)   (update-channel! (fn [x] 255) 0)   (cvt-color! COLOR_YUV2BGR)   (u/mat-view)) This gives a kind of watercolor feel to the image (Figure [3-14](#Fig14)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig14_HTML.jpg](Images/459821_1_En_3_Fig14_HTML.jpg) Figure 3-14

巧妙的猫

#### 改变

如果您还记得 transform，您还可以使用 opencv transform 函数应用不同种类的转换。

为了稍微了解一下 transform 的背景，让我们再一次回到通常的逐字节矩阵操作，首先是单通道 3×3 矩阵，我们想让它稍微暗一点。

(def s-mat (new-mat 3 3 CV_8UC1)) (.put s-mat 0 0 (byte-array [100 255 200                              100 255 200                              100 255 200]))

这可以通过以下代码查看(图 [3-15](#Fig15) )。

(u/mat-view (-> s-mat clone (resize! (new-size 30 30) 1 1 INTER_AREA))) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig15_HTML.jpg](Images/459821_1_En_3_Fig15_HTML.jpg) Figure 3-15

黑白旗帜

然后我们定义一个 1×1 的变换矩阵，一个值为 0.7。

(def t-mat   (new-mat 1 1 **CV_32F** (new-scalar 0.7))

接下来，我们就地应用转换，并转储结果以查看转换的结果。

(-> s-mat     (transform! t-mat)     (dump))

调用 transform 函数的效果是将输入矩阵的所有值转换为其原始值乘以 0.7。

结果如下表所示:

[70 178 140] [70 178 140] [70 178 140]

这也意味着垫子的视觉效果变暗了(图 [3-16](#Fig16) ):

(u/mat-view (-> s-mat (resize! (new-size 30 30) 1 1 INTER_AREA))) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig16_HTML.jpg](Images/459821_1_En_3_Fig16_HTML.jpg) Figure 3-16

深色旗帜

This is a simple matrix computation, but it already shows two things:

*   源 mat 的字节都乘以 1×1 mat 中的值；

*   应用自定义转换实际上很容易。

对于具有多个通道的垫子，这些变换的工作方式大致相同。因此，让我们抓住一个例子，并使用 cvt-color 移动到一个彩色的颜色空间(是的，我知道)!

(def s-mat (new-mat 3 3 CV_8UC1)) (.put s-mat 0 0 (byte-array [100 255 200                              100 255 200                              100 255 200])) (cvt-color! s-mat COLOR_GRAY2BGR)

因为 mat 现在由三个通道组成，所以我们现在需要一个 3×3 的变换矩阵。

下面的变形垫子会给蓝色通道更多的力量。

[ 2 0 0  ; B -> B G R   0 1 0  ; G -> B G R   0 0 1] ; R -> B G R The transformation matrix is made of lines constructed as input-channel -> output channel, so three values per row, one for each output value of each channel, and three rows , one for each input.

*   [2 0 0]将蓝色通道的值提高 2 倍，不影响绿色或红色输出值

*   [0 1 0]保持绿色通道不变，不会影响输出中的其他通道

*   [0 0 1]保持红色通道不变，同样不会影响输出中的其他通道

(def t-mat (new-mat 3 3 CV_32F)) (.put t-mat 0 0 (float-array [2 0 0                               0 1 0                               0 0 1])) Applying the transformation to the newly colored mat gives you Figure [3-17](#Fig17), where blue is prominently standing out.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig17_HTML.jpg](Images/459821_1_En_3_Fig17_HTML.jpg) Figure 3-17

蓝色标志

既然我们肯定没有办法让我姐姐的猫安静下来，那就让我们对它应用一个类似的变换。

该代码与前面的小 mat 示例完全相同，但是应用于一个图像。

(-> my-sister-cat      clone   (transform! (u/matrix-to-mat [ [2 0 0] [0 1 0] [0 0 1]]))) And Figure [3-18](#Fig18) shows a blue version of a usually white cat.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig18_HTML.jpg](Images/459821_1_En_3_Fig18_HTML.jpg) Figure 3-18

蓝米乌夫

如果您想让输入中的蓝色也影响输出中的红色，您可以使用与下图稍微类似的矩阵:

[2 0 1.1  0 1 0  0 0 1  ]

你现在应该明白为什么了吧？[2 0 1.1]表示输入中的蓝色强度增加，但它也会增加输出中红色的强度。

您可能应该自己尝试几个转换矩阵来感受一下。

那么，现在，你如何使用类似的技术来增加垫子的亮度呢？

是的，没错:首先将矩阵转换到 HSV 色彩空间，然后乘以第三个通道，并保持其他通道不变。

下面的示例以同样的方式将亮度增加 1.5。

  (-> my-sister-cat      clone   (cvt-color! COLOR_BGR2HSV)   (transform! (u/matrix-to-mat [ [1 0 0] [0 1 0] [0 0 1.5]]))   (cvt-color! COLOR_HSV2BGR)   u/mat-view) Figure [3-19](#Fig19) shows the image output of the preceding snippet.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig19_HTML.jpg](Images/459821_1_En_3_Fig19_HTML.jpg) Figure 3-19

夜光猫

#### 巧妙的转变

总结这个食谱，让我们玩一点亮度和轮廓来创造一点艺术。

我们希望通过最大化亮度来创建输入图片的水彩版本。我们还想创建一个“轮廓”版本的图像，通过使用 opencv 的轮廓检测的精明的快速功能。最后，我们将结合这两个垫的铅笔水彩效果。

首先，让我们在背景上工作。背景是通过连续执行两个变换来创建的:一个是最大化 YUV 颜色空间中的亮度，另一个是通过增加蓝色和红色来使其更加生动。

(def   usui-cat   (-> my-sister-cat      clone   (cvt-color! COLOR_BGR2YUV)   (transform! (u/matrix-to-mat [                     [20 0 0]                     [0 1 0]                     [0 0 1]]))   (cvt-color! COLOR_YUV2BGR)   (transform! (u/matrix-to-mat [[3 0 0]                                 [0 1 0]                                 [0 0 2]]))))

如果你得到一个太透明的结果，你也可以在管道的末端添加另一个变换来增加对比度；这在另一个色彩空间 HSV 中很容易做到。

  (cvt-color! COLOR_BGR2HSV)       (transform! (u/matrix-to-mat                           [[1 0 0]                           [0 3 0]                           [0 0 1]]))   (cvt-color! COLOR_HSV2BGR)     This gives us a nice pink-y background (Figure [3-20](#Fig20)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig20_HTML.jpg](Images/459821_1_En_3_Fig20_HTML.jpg) Figure 3-20

背景是粉红色的猫

接下来是前景。前面的猫是通过调用 opencv 的 canny 函数创建的。这一次，这是在单通道灰色空间中完成的。

(def   line-cat   (-> my-sister-cat       clone   (cvt-color! COLOR_BGR2GRAY)   (canny! 100.0 150.0 3 true)   (cvt-color! COLOR_GRAY2BGR)   (bitwise-not!))) The canny version of my sister’s cat gives the following (Figure [3-21](#Fig21)):![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig21_HTML.jpg](Images/459821_1_En_3_Fig21_HTML.jpg) Figure 3-21

卡通猫

然后，使用对函数**按位 and** 的简单调用将两个 mat 组合在一起，该函数通过简单的“and”位操作将两个 mat 合并在一起。

(def target (new-mat)) (bitwise-and usui-cat line-cat target) This gives the nice artful cat in Figure [3-22](#Fig22).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig22_HTML.jpg](Images/459821_1_En_3_Fig22_HTML.jpg) Figure 3-22

粉色、艺术和猫

虽然粉红色可能不是你最喜欢的颜色，但你现在有了所有的工具来根据你的喜好修改这个食谱中的流程，以创建许多不同的巧妙的猫，有不同的背景颜色，也有不同的前景。

但是拜托了。没有狗。

## 3.2 创作漫画

> 做你自己。没人能说你做错了。
> 
> [查尔斯·米·舒尔茨](https://www.goodreads.com/author/show/209672.Charles_M_Schulz)

### 问题

你已经看到了使用 **canny** 制作卡通艺术作品的非常简单的方法，但是你想掌握更多制作卡通艺术作品的变化。

### 解决办法

大多数卡通外观的转换可以使用灰度、模糊、canny 和通道滤镜功能的变化来创建，这些功能在前面的配方中已经介绍过。

### 它是如何工作的

您已经看到了 canny 函数，它以在图片中轻松突出显示形状而闻名。它实际上也可以用来画一点漫画。让我们看看我的朋友约翰。

Johan is a sharp Belgian guy who sometimes gets tricked into having a glass of good Pinot Noir (Figure [3-23](#Fig23)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig23_HTML.jpg](Images/459821_1_En_3_Fig23_HTML.jpg) Figure 3-23

乔安

在这个菜谱中，Johan 加载了以下代码片段:

(def source   (-> "resources/chapter03/johan.jpg"   (imread IMREAD_REDUCED_GRAYSCALE_8)))

一个天真的 canny 调用应该是这样的，其中 10.0 和 90.0 是 canny 函数的底部和顶部阈值，3 是光圈，true/false 表示基本上是超高亮度模式或标准(false)。

(-> source clone (canny! 10.0 90.0 3 false)) Johan has now been turned into a canny version of himself (Figure [3-24](#Fig24)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig24_HTML.jpg](Images/459821_1_En_3_Fig24_HTML.jpg) Figure 3-24

天真的 canny 用法

你已经知道我们可以使用 canny 函数的结果作为蒙版，例如在白色上复制蓝色(图 [3-25](#Fig25) )。

(def colored (u/mat-from source)) (set-to colored rgb/blue-2) (def target (u/mat-from source)) (set-to target rgb/white) (copy-to colored target c) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig25_HTML.jpg](Images/459821_1_En_3_Fig25_HTML.jpg) Figure 3-25

将蓝色复印在白色上

图中显示了相当多的线条。通过减小两个阈值之间的范围，我们可以使图片明显更清晰，看起来不那么杂乱。

(canny! 70.0 90.0 3 false) This indeed makes Johan a bit clearer (Figure [3-26](#Fig26)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig26_HTML.jpg](Images/459821_1_En_3_Fig26_HTML.jpg) Figure 3-26

更清晰的约翰

结果不错，但似乎还是多了不少不该画的线。

通常用来移除这些多余线条的技术是在调用 canny 函数之前应用一个**中值模糊**或者一个**高斯模糊**。

高斯模糊通常更有效；毫不犹豫地放大，将模糊的大小增加到至少 13×13，甚至 21×21，如下所示:

(-> source clone (cvt-color! COLOR_BGR2GRAY) (gaussian-blur! (new-size 13 13) 1 1) (canny! 70.0 90.0 3 false)) That code snippet gives a neatly clearer picture (Figure [3-27](#Fig27)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig27_HTML.jpg](Images/459821_1_En_3_Fig27_HTML.jpg) Figure 3-27

更好的约翰

你还记得双边过滤功能吗？如果你在调用 canny 函数后使用它*，它也会给出一些有趣的卡通形状，通过在 canny 效果中出现更多线条的地方进行强调。*

(->  source  clone  (cvt-color! COLOR_BGR2GRAY)  (canny! 70.0 90.0 3 false)  (bilateral-filter! 10 80 30))) Figure [3-28](#Fig28) shows the bilateral-filter! applied through a similar processing pipeline.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig28_HTML.jpg](Images/459821_1_En_3_Fig28_HTML.jpg) Figure 3-28

应用双边过滤器

你应该记得双边过滤器的重点是加强轮廓。事实上，这就是我们在这里取得的成就。

Note also that the bilateral filter parameters are very sensitive, increasing the second parameter to 120; this gives a Picasso-like rendering (Figure [3-29](#Fig29)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig29_HTML.jpg](Images/459821_1_En_3_Fig29_HTML.jpg) Figure 3-29

约翰松

所以，试试参数，看看什么对你有用。无论如何，整个折纸设置都是为了提供即时反馈。

还有，canny 不是唯一的选择。再来看看其他实现动漫效果的技巧。

#### 双边卡通

双边过滤器实际上做了大量的卡通工作，所以让我们看看我们是否可以跳过狡猾的处理，坚持只使用双边过滤器的步骤。

We will create a new function called cartoon-0\. That new function will

*   将输入图像变成灰色

*   应用非常大的双边过滤器

*   应用连续平滑函数

*   然后转回到一个 RGB 垫

一种可能的实现如下所示:

(defn cartoon-0!   [buffer]   (-> buffer     (cvt-color! COLOR_RGB2GRAY)     (bilateral-filter! 10 250 30)     (median-blur! 7)     (adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY 9 3)     (cvt-color! COLOR_GRAY2BGR)))

卡通的输出-0！应用于 Johan 使其达到图 [3-30](#Fig30) 。

(-> "resources/chapter03/johan.jpg" (imread IMREAD_REDUCED_COLOR_8) cartoon-0! u/mat-view) ![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig30_HTML.jpg](Images/459821_1_En_3_Fig30_HTML.jpg) Figure 3-30

没有精明的卡通

同样，双边滤波器的参数几乎可以完成所有工作。

改变**(双边过滤！10 250 30)** 到**(双边-过滤！9 9 7)** 给人完全不同的感觉。

(defn cartoon-1!   [buffer]   (-> buffer     (cvt-color! COLOR_RGB2GRAY)     (bilateral-filter! 9 9 7)     (median-blur! 7)     (adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY 9 3)     (cvt-color! COLOR_GRAY2BGR))) And Johan now looks even more artistic and thoughtful (Figure [3-31](#Fig31)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig31_HTML.jpg](Images/459821_1_En_3_Fig31_HTML.jpg) Figure 3-31

体贴的约翰

#### 更新频道变灰

这个食谱的最后一个技巧将带我们回到使用**更新频道！**前一个配方中编写的功能。

This new method uses update-channel with a function that

*   如果原始值小于 70，则将灰色通道的值变为 0；

*   如果原始值大于 80 但小于 180，则将其转换为 100；和

*   否则就变成 255。

这给出了以下稍微长但简单的管道:

(->   "resources/chapter03/johan.jpg"   (imread IMREAD_REDUCED_COLOR_8)   (median-blur! 1)   (cvt-color! COLOR_BGR2GRAY)   (update-channel! (fn[x] (cond (< x 70) 0 (< x 180) 100 :else 255)) 0)   (bitwise-not!)   (cvt-color! COLOR_GRAY2BGR)   (u/mat-view)) This is nothing you would not understand by now, but the pipeline is quite a pleasure to write and its result even more so, because it gives more depth to the output than the other techniques used up to now (Figure [3-32](#Fig32)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig32_HTML.jpg](Images/459821_1_En_3_Fig32_HTML.jpg) Figure 3-32

深度约翰

管道的输出看起来很棒，但是像素经过了相当多的处理，所以很难判断在这个阶段每个像素内部有什么，之后的后处理需要一些小心。

比如你想增加前面输出的亮度或者改变颜色；通常，在对颜色进行任何更改之前，最好再次切换到 HSV 颜色空间并增加亮度，如下所示:

(-> "resources/chapter03/shinji.jpg" (imread IMREAD_REDUCED_COLOR_4) (cartoon! 70 180 false) (cvt-color! COLOR_BGR2HSV) **(update-channel! (fn [x] 250) 1)** **(update-channel! (fn [x] 5) 0)** **(cvt-color! COLOR_HSV2BGR)** **(bitwise-not!)** (flip! 1) (u/mat-view)) The final processing pipeline gives us a shining blue Johan (Figure [3-33](#Fig33)). The overall color is blue due to channel 0’s value set to 5 in HSV range, and the luminosity set to 250, almost the maximum value.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig33_HTML.jpg](Images/459821_1_En_3_Fig33_HTML.jpg) Figure 3-33

翻转和蓝色

作为奖励，我们也只是水平翻转图像，以前瞻性的图片结束这个食谱！

## 3.3 创建铅笔草图

### 问题

你已经看到了如何为肖像做一些漫画，但想通过结合正面素描和深背景色来赋予它更多的艺术感。

### 解决办法

为了创建有冲击力的背景，你将会看到如何使用 pyr-down 和 pyr-up 结合你已经看到的平滑方法。

为了合并结果，我们将再次使用**位与**。

### 它是如何工作的

My hometown is in the French Alps, near the Swiss border, and there is a very nice canal flowing between the houses right in the middle of the old town (Figure [3-34](#Fig34)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig34_HTML.jpg](Images/459821_1_En_3_Fig34_HTML.jpg) Figure 3-34

夏天的法国安纳西

这里的目标是创建该图片的绘画版本。

The plan is to proceed in three phases.

> 没有计划的目标只是一个愿望。
> 
> [安托万·德圣军](https://www.goodreads.com/author/show/1020792.Antoine_de_Saint_Exup_ry)

第一阶段:我们通过平滑边缘和循环降低图片的分辨率来完全去除图片的所有轮廓。这将是背景图片。

第二阶段:我们反其道而行之，也就是说我们把注意力放在轮廓上，运用和卡通食谱中相似的技术，把图片变成灰色，找到所有的边缘，并赋予它们尽可能多的深度。这将是前面的部分。

第三阶段:最后，我们结合第一阶段和第二阶段的结果，以获得我们正在寻找的绘画效果。

#### 背景

**pyr-down！**对你来说可能是新的。这会降低图像的分辨率。让我们比较应用以下代码片段所做的分辨率更改前后的地垫。

(def factor 1) (def work (clone img)) (dotimes [_ factor] (pyr-down! work))

之前:

#object[org.opencv.core.Mat 0x3f133cac "Mat [ 431*431*CV_8UC3...]"]

之后:

#object[org.opencv.core.Mat 0x3f133cac "Mat [ 216*216*CV_8UC3...]"]

基本上，mat 的分辨率除以 2，四舍五入到像素。(是的，我以前听过 1/2 像素的故事，但是要注意……那些都不是真的！！)

Using a factor of 4, and thus applying the resolution downgrade four times, we get a mat that is now 27×27 and looks like the mat in Figure [3-35](#Fig35).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig35_HTML.jpg](Images/459821_1_En_3_Fig35_HTML.jpg) Figure 3-35

更改分辨率

为了创建背景效果，我们实际上需要一个与原始大小相同的垫子，因此需要将输出的大小调整为原始大小。

第一个想法当然是简单地尝试通常的调整大小！功能:

(resize! work (.size img)) But that does result in something not very satisfying to the eyes. Figure [3-36](#Fig36) indeed shows some quite visible weird pixelization of the resized mat.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig36_HTML.jpg](Images/459821_1_En_3_Fig36_HTML.jpg) Figure 3-36

嗯…调整大小

让我们试试别的东西。有一个 pyr-down 的反向函数，名为 pyr-up，可以将一个 mat 的分辨率提高一倍。为了有效地使用它，我们可以在一个循环中应用 pyr-up，并像使用 pyr-down 一样循环相同的次数。

(dotimes [_ factor] (pyr-up! work)) The resulting mat is similar to Figure [3-36](#Fig36), but is much smoother, as shown in Figure [3-37](#Fig37).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig37_HTML.jpg](Images/459821_1_En_3_Fig37_HTML.jpg) Figure 3-37

平滑模糊

通过在 pyr-down 和 pyr-up 舞蹈之间的垫子中应用模糊来最终确定背景。

所以:

(dotimes [_ factor] (pyr-down! work)) (bilateral-filter! work 11 11 7) (dotimes [_ factor] (pyr-up! work))

输出留到以后，后台就这样了；让我们移动到前景的边缘发现部分。

#### 前景和结果

前景将主要是前一个食谱的复制粘贴练习。你当然可以在这个阶段创造自己的变体；这里我们将使用一个由中值模糊和自适应阈值步骤组成的卡通化函数。

(def edge   (-> img     clone     (resize! (new-size (.cols output) (.rows output)))     (cvt-color! COLOR_RGB2GRAY)     (median-blur! 7)     (adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY 9 7)     (cvt-color! COLOR_GRAY2RGB))) Using the old town image as input, this time you get a mat showing only the prominent edges, as shown in Figure [3-38](#Fig38).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig38_HTML.jpg](Images/459821_1_En_3_Fig38_HTML.jpg) Figure 3-38

到处都是边缘

为了完成这个练习，我们现在使用按位 and 将两个垫子组合起来。基本上，由于边缘是黑色的，按位 and 运算使它们保持黑色，它们的值将被复制到输出 mat。

这将具有将未改变的边缘复制到目标结果上的结果，并且由于边缘垫的剩余部分是由白色构成的，按位与将是另一个垫的值，因此背景垫的颜色将优先。

(let [result (new-mat) ]   (bitwise-and work edge result)   (u/mat-view result)) This gives you the sketching effect of Figure [3-39](#Fig39).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig39_HTML.jpg](Images/459821_1_En_3_Fig39_HTML.jpg) Figure 3-39

像专业人士一样素描

使用“自适应阈值”步骤，可以调整正面草图的外观。

(adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY     edges-thickness edges-number)

在第一张草图中，我们用 9 作为边厚，7 作为边数；让我们看看如果我们把这两个参数设为 5 会发生什么。

This gives more space to the color of the background, by reducing the thickness of the edges (Figure [3-40](#Fig40)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig40_HTML.jpg](Images/459821_1_En_3_Fig40_HTML.jpg) Figure 3-40

较薄的边缘

现在就看你的发挥了，从那里随机应变！

#### 摘要

Finally, let’s get you equipped with a ready-to-use sketch! function. This is an exact copy of the code that has been used up to now, with places for the most important parameters for this sketching technique:

*   用于降低分辨率然后再次提高分辨率的因素，例如舞蹈中的循环次数

*   背景双边滤波器的参数

*   前景的自适应阈值的参数

素描！函数是由平滑构成的！还有棱角！。首先，让我们使用平滑！来创造背景。

(defn smoothing!   [img factor filter-size filter-value]   (let [ work (clone img) output (new-mat)]   (dotimes [_ factor] (pyr-down! work))   (bilateral-filter work output filter-size filter-size filter-value)   (dotimes [_ factor] (pyr-up! output))   (resize! output (new-size (.cols img) (.rows img)))))

然后边缘！来创造前景。

(defn edges!   [img e1 e2 e3]   (-> img     clone     (cvt-color! COLOR_RGB2GRAY)     (median-blur! e1)     (adaptive-threshold! 255 ADAPTIVE_THRESH_MEAN_C THRESH_BINARY e2 e3)     (cvt-color! COLOR_GRAY2RGB)))

终于可以用素描了！，背景和前景的结合。

(defn sketch!   [ img s1 s2 s3 e1 e2 e3]     (let [ output (smoothing! img s1 s2 s3) edge (edges! img e1 e2 e3)]     (bitwise-and output edge output)     output))

召唤素描！是比较容易的。您可以尝试下面的代码片段:

  (sketch! 6 9 7  7 9 11) And instantly turn the landscape picture of Figure [3-41](#Fig41) …![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig41_HTML.jpg](Images/459821_1_En_3_Fig41_HTML.jpg) Figure 3-41

树

into the sketched version of Figure [3-42](#Fig42).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig42_HTML.jpg](Images/459821_1_En_3_Fig42_HTML.jpg) Figure 3-42

风景素描

其他几个已经放入了示例中，但是现在确实是时候拍摄您自己的照片并尝试这些功能和参数了。

## 3.4 创建画布效果

### 问题

创造景观艺术对你来说似乎没有更多的秘密，但你想在它上面浮雕一块画布，使它更像一幅画。

### 解决办法

这个简短的食谱将重复使用你已经看到的技术，以及两个新的 mat 函数:**乘**和**除。**

使用 divide，可以创建一个垫子的燃烧和躲闪效果，我们将使用它们来创建想要的效果。

有了**乘**，就有可能将垫子组合成一个漂亮的深度效果，因此通过使用一个看起来像纸一样的背景垫子，就有可能在画布上产生一个特殊的绘制输出。

### 它是如何工作的

我们将在法国阿尔卑斯山再拍一张照片——我是说为什么不呢！—因为我们想让它看起来有点复古，我们将使用一个古老城堡的图像。

(def img   (-> "resources/chapter03/montrottier.jpg"   (imread IMREAD_REDUCED_COLOR_4))) Figure [3-43](#Fig43) shows the castle of Montrottier, which you should probably visit when you have the time, or vacation (I do not even know what the second word means anymore).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig43_HTML.jpg](Images/459821_1_En_3_Fig43_HTML.jpg) Figure 3-43

向星星许愿

我们首先从应用一个**位非开始！**，然后在源图片的灰色克隆上进行**高斯模糊**；用折纸管道很容易做到这一点。

我们将需要一个灰色的版本，所以让我们保持两个垫子灰色和 gaussed 分开。

(def gray   (-> img clone (cvt-color! COLOR_BGR2GRAY))) (def gaussed   (-> gray       clone       bitwise-not!       (gaussian-blur! (new-size 21 21) 0.0 0.0))) Figure [3-44](#Fig44) shows the gaussed mat, which looks like a spooky version of the input image.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig44_HTML.jpg](Images/459821_1_En_3_Fig44_HTML.jpg) Figure 3-44

幽灵城堡

我们将使用这个 gaussed 垫作为一个面具。神奇的事情发生在函数**道奇！**，在原图上使用 opencv 函数 divide，以及 gaussed mat 的反转版本。

(defn dodge! [img_ mask]   (let [ output (clone img_) ]   (divide img_ (bitwise-not! (-> mask clone)) output 256.0)   output))

嗯……好吧。除法是做什么的？我的意思是，你知道它划分事物，但是在字节水平上，真正发生的是什么？

我们举两个矩阵，a 和 b，对它们调用 divide 作为例子。

(def a (u/matrix-to-mat [[1 1 1]])) (def b (u/matrix-to-mat [[0 1 2]])) (def c (new-mat)) (divide a b c 10.0) (dump c)

divide 调用的输出是

[0 10 5]

哪个是

[ (a0 / b0) * 10.0, (a1 / b1) * 10.0, (a2 / b2) * 10.0]

这给了

[ 1 / 0 * 10.0, 1 / 1 * 10.0, 1 / 2 * 10.0]

那么，鉴于 OpenCV 认为除以 0 等于 0:

[0, 10, 5]

现在，让我们打电话给道奇！在灰色垫子和格纹垫子上:

(u/mat-view (dodge! gray gaussed)) And see the sharp result of Figure [3-45](#Fig45).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig45_HTML.jpg](Images/459821_1_En_3_Fig45_HTML.jpg) Figure 3-45

锋利的铅笔

#### 应用画布

现在，主画面已经变成了蜡笔风格的艺术形式，把它放在一个看起来像帆布的垫子上会很好。如前所述，这是使用 OpenCV 中的**乘**函数完成的。

We want the canvas to look like a very old parchment, and we will use the one from Figure [3-46](#Fig46).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig46_HTML.jpg](Images/459821_1_En_3_Fig46_HTML.jpg) Figure 3-46

旧羊皮纸

现在我们将创建**应用画布！**函数，接受前端草图和画布，并在它们之间应用乘法函数。(/ 1 256.0)是用于相乘的值；因为这里是灰色字节，值越大越白，所以这里(/ 1 256.0)使得最终结果上的黑线非常明显。

(defn apply-canvas! [ sketch canvas]  (let [ out (new-mat)]   (resize! canvas (new-size (.cols sketch) (.rows sketch)))   (multiply    (-> sketch clone (cvt-color! COLOR_GRAY2RGB)) canvas out (/ 1 256.0))     out))

呜呼。差不多了；现在让我们调用这个新创建的函数

(u/mat-view (apply-canvas! sketch canvas)) And enjoy the drawing on the canvas (Figure [3-47](#Fig47)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig47_HTML.jpg](Images/459821_1_En_3_Fig47_HTML.jpg) Figure 3-47

旧羊皮纸上的城堡

现在显然是你去寻找/扫描你自己的旧论文的时候了，用这种技术尝试一些事情；或者为什么不重用以前食谱中的卡通功能来覆盖不同的纸张呢？

## 3.5 突出显示线条和圆圈

### 问题

这个食谱是关于如何在一个加载的垫子中找到并高亮显示线条、圆圈和线段的。

### 解决办法

通常需要一点预处理来准备图像，以便用一些谨慎和平滑的操作进行分析。

一旦第一步准备工作完成，就可以用 opencv 函数 hough-circles 找到圆。

查找线条的版本称为 hough-lines，其兄弟 hough-lines-p 使用概率来查找更好的线条。

最后，我们将看到如何使用线段检测器来绘制找到的线段。

### 它是如何工作的

#### 用霍夫线寻找网球场的线

本教程的第一部分展示了如何在图像中寻找线条。我们将以网球场为例。

(def tennis (-> "resources/chapter03/tennis_ground.jpg" imread )) You have probably seen a tennis court before, and this one is not so different from the others (Figure [3-48](#Fig48)). If you have never seen a tennis court before, this is a great introduction all the same, but you should probably stop reading and go play a game already.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig48_HTML.jpg](Images/459821_1_En_3_Fig48_HTML.jpg) Figure 3-48

网球场

为 hough-lines 函数准备目标是通过将原始网球场图片转换为灰色，然后应用简单的 canny 变换来完成的。

(def can       (-> tennis         clone         (cvt-color! COLOR_BGR2GRAY)         (canny! 50.0 180.0 3 false))) With the expected result of the lines standing out on a black background, as shown in Figure [3-49](#Fig49).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig49_HTML.jpg](Images/459821_1_En_3_Fig49_HTML.jpg) Figure 3-49

漂亮的网球场

在 opencv 的底层 Java 版本中，行被收集在一个 mat 中，因此，无法避免这一点，我们也将准备一个 mat 来接收结果行。

hough-lines 函数本身是用一组参数调用的。可以在 OpenCV 网站上找到霍夫变换的完整的基本极坐标系统解释:

[https://docs . opencv . org/3 . 3 . 1/d9/db0/tutorial _ Hough _ lines . html](https://docs.opencv.org/3.3.1/d9/db0/tutorial_hough_lines.html)

你真的不需要现在就阅读所有的东西，但是意识到什么可以做什么不可以做是很好的。

现在，我们将只应用链接教程中建议的相同参数。

(def lines (new-mat)) (hough-lines can lines 1 (/ Math/PI 180) 100)

得到的线条矩阵由一列行组成，每行有两个值 rho 和 theta。

创建从 rho 和 theta 画线所需的两个点有点复杂，但在 opencv 教程中有描述。

现在，下面的函数为您完成了工作。

(def result (clone parking)) (dotimes [ i (.rows lines)]    (let [ val_ (.get lines i 0)           rho (nth val_ 0)           theta (nth val_ 1)           a (Math/cos theta)           b (Math/sin theta)           x0 (* a rho)           y0 (* b rho)           pt1 (new-point               (Math/round (+ x0 (* 1000 (* -1 b))))               (Math/round (+ y0 (* 1000 a))))           pt2 (new-point               (Math/round (- x0 (* 1000 (* -1 b))))               (Math/round (- y0 (* 1000 a))))             ]   (line result pt1 pt2 color/black 1))) Drawing the found lines on top of the tennis court mat creates the image in Figure [3-50](#Fig50).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig50_HTML.jpg](Images/459821_1_En_3_Fig50_HTML.jpg) Figure 3-50

霍夫线结果

请注意，当调用 hough-lines 时，将值为 1 的参数更改为值为 2 会得到更多的行，但是您可能需要在之后自己过滤这些行。

同样根据经验，将数学/圆周率舍入从 180°更改为 90°会产生更少的行，但结果会更好。

#### 霍夫线 P

hough-lines 函数的另一个变体，名为 hough-lines-p，是一个添加了概率数学的增强版本，它通常通过执行猜测来给出一组更好的线。

为了用 P 来尝试霍夫线，我们这次将以…一个足球场为例。

(def soccer-field   (-> "resources/chapter03/soccer-field.jpg"       (imread IMREAD_REDUCED_COLOR_4))) (u/mat-view soccer-field)

按照最初的 hough-lines 示例，我们将足球场变成灰色，并应用轻微的高斯模糊来消除源图像中可能的缺陷。

(def gray          (-> soccer-field       clone       (cvt-color! COLOR_BGR2GRAY)       (gaussian-blur! (new-size 1 1) 0 ) )) The resulting grayed version of the soccer field is shown in Figure [3-51](#Fig51).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig51_HTML.jpg](Images/459821_1_En_3_Fig51_HTML.jpg) Figure 3-51

灰色足球场

现在让我们制作一个巧妙的球场来创建边缘。

(def edges (-> gray clone (canny! 100 220)))

现在，我们调用 **hough-lines-p.** 在下面的代码片段中解释了所使用的参数。预计将从新创建的边垫中收集线。

; distance resolution in pixels of the Hough grid (def rho 1) ; angular resolution in radians of the Hough grid (def theta  (/ Math/PI 180)) ; minimum number of votes (intersections in Hough grid cell) (def min-intersections 30) ; minimum number of pixels making up a line (def min-line-length  10) ; maximum gap in pixels between connectable line segments (def max-line-gap  50)

参数准备好了；让我们调用 hough-lines-p，结果存储在 **lines** mat 中。

(def lines (new-mat)) (hough-lines-p   edges   lines   rho   theta   min-intersections   min-line-length   max-line-gap)

这一次，线条比常规的 hough-lines 函数更容易绘制。结果矩阵的每一行都由四个值组成，这四个值对应于绘制该行所需的两个点。

(def result (clone soccer-field)) (dotimes [ i (.rows lines)] (let [ val (.get lines i 0)]   (line result     (new-point (nth val 0) (nth val 1))     (new-point (nth val 2) (nth val 3))     color/black 1))) The result of drawing the results of hough-lines-p is displayed in Figure [3-52](#Fig52).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig52_HTML.jpg](Images/459821_1_En_3_Fig52_HTML.jpg) Figure 3-52

足球场上的线

#### 在台球桌上找口袋

不再在球场上跑来跑去；让我们移动到…台球桌！

以类似的方式，opencv 有一个名为 hough-circles 的函数来寻找看起来像圆的形状。更重要的是，这个功能很容易实现。

This time, let’s try to find the ball pockets of a billiard table. The exercise is slightly difficult because it is easy to wrongly count the regular balls as pockets.

> 你不能在没有准备好的情况下敲开机会的大门。
> 
> 布鲁诺·马尔斯

我们先把台球桌准备好。

(def pool   (->     "resources/chapter03/pooltable.jpg"     (imread IMREAD_REDUCED_COLOR_2)))

使用 hough-circles，似乎可以通过绕过预处理中的谨慎步骤来获得更好的结果。

下面的代码片段显示了要在源 mat 中查找的圆的最小和最大半径值的位置。

(def gray (-> pool clone (cvt-color! COLOR_BGR2GRAY))) (def minRadius 13) (def maxRadius 18) (def circles (new-mat)) (hough-circles gray circles CV_HOUGH_GRADIENT 1   minRadius 120 10 minRadius maxRadius)

这里，圆被收集在一个垫子中，每条线包含圆心的 x 和 y 位置及其半径。

最后，我们简单地用 opencv **circle** 函数在结果 mat 上画圆。

(def output (clone pool)) (dotimes [i (.cols circles)]   (let [ _circle (.get circles 0 i)          x (nth _circle 0)          y (nth _circle 1)          r (nth _circle 2)            p (new-point x y)] (circle output p (int r) color/white 3))) All the pockets are now highlighted in white in Figure [3-53](#Fig53).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig53_HTML.jpg](Images/459821_1_En_3_Fig53_HTML.jpg) Figure 3-53

白色台球桌的口袋！

Note that if you put the minRadius value too low, you quickly get false positives with the regular balls, as shown in Figure [3-54](#Fig54).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig54_HTML.jpg](Images/459821_1_En_3_Fig54_HTML.jpg) Figure 3-54

假口袋

因此，精确定义要搜索的内容是大多数 OpenCV 工作(也许还有其他工作)成功的秘诀。

因此，为了避免这里的假阳性，在接受和画线之前过滤颜色可能也是一个好主意。接下来看看怎么做。

#### 寻找圆圈

在这个简短的例子中，我们将寻找垫子中的红色圆圈，在垫子中可以找到多种颜色的圆圈。

(def bgr-image   (-> "resources/detect/circles.jpg" imread (u/resize-by 0.5) )) The bgr-image is shown in Figure [3-55](#Fig55).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig55_HTML.jpg](Images/459821_1_En_3_Fig55_HTML.jpg) Figure 3-55

彩色圆圈

如果你直接阅读这本书的黑白版本，你可能看不到它，但我们将把注意力集中在左下角的大圆圈上，它是一个鲜艳的红色。

如果你还记得以前食谱中的经验，你已经知道我们需要将色彩空间转换为 HSV，然后过滤 0 到 10 之间的色调范围。

下面的代码片段展示了如何使用一些额外的模糊来实现这一点，以方便以后的处理。

(def ogr-image   (-> bgr-image    (clone)    (median-blur! 3)    (cvt-color! COLOR_BGR2HSV)    (in-range! (new-scalar 0 100 100) (new-scalar 10 255 255))    (gaussian-blur! (new-size 9 9) 2 2))) All the circles we are not looking for have disappeared from the mat resulting from the small pipeline, and the only circle we are looking for is now standing out nicely (Figure [3-56](#Fig56)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig56_HTML.jpg](Images/459821_1_En_3_Fig56_HTML.jpg) Figure 3-56

红色圆圈显示为白色

现在，我们可以应用与之前看到的相同的霍夫圆调用；同样，圆圈将被收集在圆圈垫中，这将是一个 1×1 的垫，具有三个通道。

(def circles (new-mat)) (hough-circles ogr-image circles CV_HOUGH_GRADIENT 1 (/ (.rows bgr-image) 8) 100 20 0 0) (dotimes [i (.cols circles)]   (let [ _circle (.get circles 0 i)          x (nth _circle 0)          y (nth _circle 1)          r (nth _circle 2)            p (new-point x y)]   (circle bgr-image p (int r) rgb/greenyellow 5))) The result of drawing the circle with a border is shown in Figure [3-57](#Fig57). The red circle has been highlighted with a green-yellow color and a thickness of 5.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig57_HTML.jpg](Images/459821_1_En_3_Fig57_HTML.jpg) Figure 3-57

突出显示的红色圆圈

#### 使用绘制线段

有时，最简单的方法可能是简单地使用所提供的片段检测器。它对折纸不太友好，因为使用的方法是直接的 Java 方法调用(所以前缀是点“.”)，但是片段比较自成一体。

让我们在之前看到的足球场上试试。这次我们将它直接加载到 gray，并观察分段检测器的行为。

(def soccer-field     (-> "resources/chapter03/soccer-field.jpg"     (imread IMREAD_REDUCED_GRAYSCALE_4))) (def det (create-line-segment-detector)) (def lines (new-mat)) (def result (clone soccer-field))

我们在线段检测器上调用 **detect** ，现在使用 Clojure Java Interop。

(.detect det soccer-field lines)

在这个阶段，lines mat 元数据是 161*1*CV_32FC4，意味着 161 行，每行由 1 列和每个点的 4 个通道组成，意味着每个值 2 个点。

检测器有一个有用的 drawSegments 函数，我们可以调用它来获得结果 mat。

(.drawSegments det result lines) The soccer field mat is now showing in Figure [3-58](#Fig58), this time with all the lines highlighted, including circles and semicircles.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig58_HTML.jpg](Images/459821_1_En_3_Fig58_HTML.jpg) Figure 3-58

第一季第一集

## 3.6 查找并绘制轮廓和边界框

### 问题

由于识别和计算形状是 OpenCV 使用的前沿，您可能想知道如何在折纸中使用轮廓查找技术。

### 解决办法

除了传统的清理和图像准备，这个方法将引入 **find-contours** 函数来填充轮廓列表。

一旦找到轮廓，我们需要应用一个简单的过滤器来去除非常大的轮廓，如整个图片，以及实在太小而无用的轮廓。

一旦过滤完成，我们可以使用手工绘制的圆形和矩形或者提供的函数**绘制轮廓**来绘制轮廓。

### 它是如何工作的

#### 索尼耳机

它们不再那么新了，但我爱我的索尼耳机。我只是带着它们到处走，你可以满足你的自恋，并通过简单地穿着它们获得你需要的所有关注。无论是在火车上还是在飞机上，它们都能带给你最好的声音…

让我们来玩一个快速寻找耳机轮廓的游戏。

(def headphones   (-> "resources/chapter03/sonyheadphones.jpg"         (imread IMREAD_REDUCED_COLOR_4)))

我的耳机仍然有一根电缆，因为我更喜欢声音，不管一些大公司怎么说。

Anyway, the headphones are shown in Figure [3-59](#Fig59).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig59_HTML.jpg](Images/459821_1_En_3_Fig59_HTML.jpg) Figure 3-59

带线缆的索尼耳机

首先，我们需要准备耳机，以便更容易分析。为此，我们创建了一个有趣的部分，耳机本身的面具。

(def mask   (-> headphones       (cvt-color! COLOR_BGR2GRAY)       (clone)       (threshold! 250 255 THRESH_BINARY_INV)       (median-blur! 7))) The inverted thresh binary output is shown in Figure [3-60](#Fig60).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig60_HTML.jpg](Images/459821_1_En_3_Fig60_HTML.jpg) Figure 3-60

蒙面耳机

然后，通过使用蒙版，我们创建了一个蒙版输入 mat，它将用于简化轮廓查找步骤。

(def masked-input   (clone headphones)) (set-to masked-input (new-scalar 0 0 0) mask) (set-to masked-input (new-scalar 255 255 255) (bitwise-not! mask))

你注意到了吗？是的，创建输入有一种更简单的方法，首先简单地创建一个非反转遮罩，但第二种方法为准备输入垫提供了更多的控制。

所以这里我们基本上分两步走。首先，当蒙版的相同像素值为 1 时，将原始 mat 的所有像素设置为黑色。下一步，设置所有其他的值为白色，在相反版本的面具。

The prepared result mat is in Figure [3-61](#Fig61).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig61_HTML.jpg](Images/459821_1_En_3_Fig61_HTML.jpg) Figure 3-61

输入垫的准备

现在，用于查找轮廓的 mat 已经准备好了，您几乎可以直接在它上面调用 find-contours。

**find-contours** 有几个明显的参数，还有两个，最后两个，有点模糊。

**RETR _ 列表**是最简单的一种，将所有轮廓作为列表返回，而**RETR _ 树**是最常用的，表示轮廓是分层有序的。

**CHAIN_APPROX_NONE** 表示找到的轮廓的所有点被存储。不过，通常在绘制这些轮廓时，并不需要定义它们的所有点。如果不需要所有的点，可以使用 **CHAIN_APPROX_SIMPLE** ，减少定义轮廓的点数。

这最终取决于你如何处理之后的轮廓。但是现在，让我们保持所有的点！

(def contours   (new-arraylist)) (find-contours   masked-input   contours   (new-mat) ; mask   RETR_TREE   CHAIN_APPROX_NONE)

好的，现在让我们画矩形来突出每个找到的轮廓。我们在轮廓列表上循环，对于每个轮廓，我们使用 **bounding-rect** 函数来获得一个包围轮廓本身的矩形。

从 bounding-rect 调用中获取的矩形几乎可以原样使用，我们将用它来绘制我们的第一个轮廓。

(def exercise-1 (clone headphones)) (doseq [c contours]   (let [ rect (bounding-rect c)]    (rectangle      exercise-1      (new-point (.x rect) (.y rect))      (new-point (+ (.width rect) (.x rect)) (+ (.y rect) (.height rect)))      (color/->scalar "#ccffcc")      2))) Contours are now showing in Figure [3-62](#Fig62).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig62_HTML.jpg](Images/459821_1_En_3_Fig62_HTML.jpg) Figure 3-62

头电话轮廓

没错。还不错。从图中可以很明显地看出，覆盖整个画面的大矩形并不是很有用。这就是为什么我们需要一点过滤。

Let’s filter the contours, by making sure they are

*   不要太小，这意味着它们应该覆盖的面积至少为 10，000，也就是 125×80 的表面。

*   也不能太大，也就是说高度不能覆盖整个画面。

下面的代码片段完成了过滤。

(def interesting-contours   (filter     #(and        (> (contour-area %) 10000 )        (< (.height (bounding-rect %)) (- (.height headphones) 10)))     contours))

所以，这次只画出有趣的轮廓就相当准确了。

(def exercise-1 (clone headphones)) (doseq [c **interesting-contours**]     ...) Figure [3-63](#Fig63) this time shows only useful contours.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig63_HTML.jpg](Images/459821_1_En_3_Fig63_HTML.jpg) Figure 3-63

耳机有趣的外形

画圆而不是矩形应该不会太难，所以我们在有趣的轮廓上做同样的循环，但是这次，基于边界矩形画一个圆。

(def exercise-2 (clone headphones)) (doseq [c interesting-contours]  (let [ rect (bounding-rect c) center (u/center-of-rect rect) ]    (circle exercise-2            center            (u/distance-of-two-points center (.tl rect))            (color/->scalar "#ccffcc")             2))) The resulting mat, exercise-2, is shown in Figure [3-64](#Fig64).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig64_HTML.jpg](Images/459821_1_En_3_Fig64_HTML.jpg) Figure 3-64

在它上面盘旋

最后，虽然它很难用于检测处理，但您也可以使用 opencv 函数 **draw-contours** 来很好地绘制轮廓的自由形状。

我们仍将在有趣轮廓列表上循环。请注意，参数可能感觉有点奇怪，因为绘制轮廓使用的是索引和列表，而不是轮廓本身，所以在使用绘制轮廓时要小心。

(def exercise-3 (clone headphones)) (dotimes [ci (.size interesting-contours)]  (draw-contours    exercise-3    interesting-contours    ci    (color/->scalar "#cc66cc")    3)) And finally, the resulting mat can be found in Figure [3-65](#Fig65).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig65_HTML.jpg](Images/459821_1_En_3_Fig65_HTML.jpg) Figure 3-65

耳机和粉色轮廓

事情并不总是那么容易，那我们再举一个天上掉馅饼的例子吧！

#### 在天空中

第二个例子以天空中的热气球为例，希望在上面绘制轮廓。

The picture of hot-air balloons in Figure [3-66](#Fig66) seems very innocent and peaceful.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig66_HTML.jpg](Images/459821_1_En_3_Fig66_HTML.jpg) Figure 3-66

热气球

不幸的是，使用与前面所示相同的技术来准备图片并不能达到非常性感的效果。

(def wrong-mask   (-> kikyu       clone       (cvt-color! COLOR_BGR2GRAY)       (threshold! 250 255 THRESH_BINARY)       (median-blur! 7))) It’s pretty pitch-black in Figure [3-67](#Fig67).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig67_HTML.gif](Images/459821_1_En_3_Fig67_HTML.gif) Figure 3-67

有人在上面吗？

所以，让我们试试另一种技术。为了得到更好的口罩，你会怎么做？

是的——为什么不呢？让我们过滤所有这些蓝色，并从中创建一个模糊的面具。这将为您提供以下代码片段。

(def mask   (-> kikyu       (clone)       (cvt-color! COLOR_RGB2HSV)       (in-range! (new-scalar 10 30 30) (new-scalar 30 255 255))       (median-blur! 7))) Nice! Figure [3-68](#Fig68) shows that this actually worked out pretty neatly.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig68_HTML.jpg](Images/459821_1_En_3_Fig68_HTML.jpg) Figure 3-68

有用的面具

我们现在将使用补充版本的面具来寻找轮廓。

(def work (-> mask bitwise-not!))

使用查找轮廓功能，没有更多的秘密向你隐藏。或许是吧？参数表中的**新点**在做什么？不用担心；它只是一个偏移量，这里我们没有指定偏移量，所以 0 0。

(def contours (new-arraylist)) (find-contours work contours (new-mat) RETR_LIST CHAIN_APPROX_SIMPLE (new-point 0 0))

轮廓在里面！让我们过滤尺寸，并在它们周围画圆。这只是上一个例子的重复。

(def output_ (clone kikyu)) (doseq [c contours]   (if (> (contour-area c) 50 )     (let [ rect (bounding-rect c)]       (if (and  (> (.height rect) 40)  (> (.width rect) 60))       (circle         output_         (new-point (+ (/ (.width rect) 2) (.x rect))                    (+ (.y rect) (/ (.height rect) 2)))         100         rgb/tan         5))))) Nice. You are getting pretty good at those things. Look at and enjoy the result of Figure [3-69](#Fig69).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig69_HTML.jpg](Images/459821_1_En_3_Fig69_HTML.jpg) Figure 3-69

在热气球上盘旋

接下来，让我们在绘图之前进行过滤，并再次使用 bounding-rect 来绘制矩形。

(def my-contours   (filter   #(and   (> (contour-area %) 50 )   (> (.height (bounding-rect %)) 40)     (> (.width (bounding-rect %)) 60))                     contours))

的确，如果你检查它的内容，我的轮廓只有三个元素。

(doseq [c my-contours]   (let [ rect (bounding-rect c)]    (rectangle      output      (new-point (.x rect) (.y rect))      (new-point (+ (.width rect) (.x rect)) (+ (.y rect) (.height rect)))      rgb/tan      5))) Now drawing those rectangles results in Figure [3-70](#Fig70).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig70_HTML.jpg](Images/459821_1_En_3_Fig70_HTML.jpg) Figure 3-70

热气球上的长方形

## 3.7 关于轮廓的更多信息:使用形状

### 问题

继续上一个食谱，您将会看到函数 find-contours 返回了什么。用所有的点绘制轮廓是不错的，但是如果你想用不同的颜色突出不同的形状呢？

此外，如果形状是手绘的，或者在源 mat 中显示不正确怎么办？

### 解决办法

我们仍然要像到目前为止所做的那样使用查找轮廓和绘制轮廓，但是我们要在绘制它们之前对每个轮廓做一些预处理，以找出它们有多少条边。

**近似-多边形-** **dp** 是用于近似形状的函数，从而减少点的数量，只保留多边形形状中最重要的点。我们将创建一个小函数，**approximate，**将形状转换成多边形，并计算它们的边数。

我们还将看看**填充凸多边形**，看看我们如何绘制手写形状的近似轮廓。

最后，另一个名为**折线**的 opencv 函数将用于只绘制找到的轮廓的线框。

### 它是如何工作的

#### 突出轮廓

We will use a picture with many shapes for the first part of this exercise, like the one in Figure [3-71](#Fig71).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig71_HTML.jpg](Images/459821_1_En_3_Fig71_HTML.jpg) Figure 3-71

形状

这里的目标是根据每个形状的边数，用不同的颜色绘制每个形状的轮廓。

shapes mat 只需加载以下代码片段:

(def shapes   (-> "resources/morph/shapes3.jpg" (imread IMREAD_REDUCED_COLOR_2)))

正如在前面的配方中所做的，我们首先通过将输入的克隆转换为灰色来准备一个 thresh mat，然后应用一个简单的阈值来突出显示形状。

(def thresh (->     shapes     clone     (cvt-color! COLOR_BGR2GRAY)     (threshold! 210 240 1))) (def contours (new-arraylist)) Looking closely, we can see that the shapes are nicely highlighted, and if you look at Figure [3-72](#Fig72), the thresh is indeed nicely showing the shapes.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig72_HTML.jpg](Images/459821_1_En_3_Fig72_HTML.jpg) Figure 3-72

功能脱粒机

好了，thresh 准备好了，所以你现在可以调用 **find-contours** 了。

(find-contours thresh contours (new-mat) RETR_LIST CHAIN_APPROX_SIMPLE)

为了绘制轮廓，我们首先编写一个 dump 函数，它在轮廓列表上循环，并用洋红色绘制每个轮廓。

(defn draw-contours! [img contours]  (dotimes [i (.size contours)]     (let [c (.get contours i)]      (draw-contours img contours i rgb/magenta-2 3)))     img) (-> shapes       (draw-contours! contours)       (u/mat-view)) The function works as expected, and the result is shown in Figure [3-73](#Fig73).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig73_HTML.jpg](Images/459821_1_En_3_Fig73_HTML.jpg) Figure 3-73

洋红色轮廓

但是，正如我们已经说过的，我们希望为每个轮廓使用不同的颜色，所以让我们编写一个函数，根据轮廓的边来选择颜色。

(defn which-color[c]   (condp = (how-many-sides c)    1 rgb/pink    2 rgb/magenta-    3 rgb/green    4 rgb/blue    5 rgb/yellow-1-    6 rgb/cyan-2    rgb/orange))

不幸的是，即使将 **CHAIN_APPROX_SIMPLE** 作为参数传递给 find-contours，每个形状的点数仍然太高，没有任何意义。

8, 70, 132, 137...

因此，让我们通过将形状转换为近似值来减少点数。

opencv 中使用了两个函数:弧长函数和近似多边形函数。因子 0.02 是 opencv 提出的默认值；稍后我们将在这个食谱中看到不同值的影响。

(defn approx [c]   (let[m2f (new-matofpoint2f (.toArray c))        len (**arc-length** m2f true)        ret (new-matofpoint2f)        app (**approx-poly-dp** m2f ret (* 0.02 len) true)]     ret))

使用这个新的**近似值**函数，我们现在可以通过计算近似值的点数来计算边数。

下面是一个简单的多少边函数。

(defn how-many-sides[c]   (let[nb-sides (.size (.toList  c))]     nb-sides))

一切就绪；让我们重写愚蠢的轮廓图！使用 which-color 函数变成稍微进化的东西。

(defn draw-contours! [img contours]  (dotimes [i (.size contours)]     (let [c (.get contours i)]      (draw-contours img contours i (which-color c) 3)))     img) And now calling the updated function properly highlights the polygons, counting the number of sides on an approximation of each of the found shapes (Figure [3-74](#Fig74)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig74_HTML.jpg](Images/459821_1_En_3_Fig74_HTML.jpg) Figure 3-74

不同形状，不同颜色

请注意这个圆仍然有点过分，有太多的边，但这是意料之中的。

#### 手绘形状

但也许你会说，形状已经很好地显示出来了，所以你仍然对近似是否真的有用有些怀疑。因此，让我们来看一幅美丽的手绘艺术作品，它正是为了这个例子而准备的。

(def shapes2   (-> "resources/chapter03/hand_shapes.jpg"       (imread IMREAD_REDUCED_COLOR_2))) Figure [3-75](#Fig75) shows the newly loaded shapes.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig75_HTML.jpg](Images/459821_1_En_3_Fig75_HTML.jpg) Figure 3-75

一件艺术品

首先，让我们调用 find-contours 并画出由它们定义的形状。

Reusing the same **draw-contours**! function and drawing over the art itself gives Figure [3-76](#Fig76).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig76_HTML.jpg](Images/459821_1_En_3_Fig76_HTML.jpg) Figure 3-76

艺术上的轮廓

现在这一次，让我们尝试一些不同的东西，使用核心 opencv 包中的函数 **fill-convex-poly** 。

这与绘制轮廓没有太大的不同，我们实际上只是在列表上循环，并在每个轮廓上使用填充凸多边形。

(def drawing (u/mat-from shapes2)) (set-to drawing rgb/white) (let[ contours (new-arraylist)]     (find-contours thresh contours (new-mat) RETR_LIST CHAIN_APPROX_SIMPLE)   (doseq [c contours]     (fill-convex-poly drawing c rgb/blue-3- LINE_4 1))) And so, we get the four shapes turned to blue (Figure [3-77](#Fig77)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig77_HTML.jpg](Images/459821_1_En_3_Fig77_HTML.jpg) Figure 3-77

一件艺术品变成了蓝色

正如我们所看到的，轮廓和形状被发现并且可以被画出来。

另一种绘制等高线的方法是使用函数**折线**。幸运的是，函数**折线**隐藏了轮廓每个元素上的循环，您可以直接将轮廓列表作为参数传入。

(set-to drawing rgb/white) (let[ contours (new-arraylist)]     (find-contours             thresh             contours             (new-mat)             RETR_LIST             CHAIN_APPROX_SIMPLE)     (polylines drawing contours true rgb/magenta-2)) (-> drawing clone (u/resize-by 0.5) u/mat-view) And this time, we nicely get the wireframe only of the contours (Figure [3-78](#Fig78)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig78_HTML.jpg](Images/459821_1_En_3_Fig78_HTML.jpg) Figure 3-78

艺术线框

好的，但是现在这些形状都有太多的点。

让我们再次使用创建的近似函数，并增强它，以便我们可以指定近似聚合 dp 使用的因子。

(defn approx_   ([c] (approx_ c 0.02))   ([c factor]   (let[m2f (new-matofpoint2f (.toArray c))        len (arc-length m2f true)        ret (new-matofpoint2f)]     (approx-poly-dp m2f ret (* factor len) true)     (new-matofpoint (.toArray ret)))))

更高的系数意味着我们在更大程度上强制减少点数。因此，为了达到这个效果，让我们将通常的值 0.02 增加到 0.03。

(set-to drawing rgb/white) (let[ contours (new-arraylist)]     (find-contours thresh contours (new-mat) RETR_LIST CHAIN_APPROX_SIMPLE)   (doseq [c contours]    (fill-convex-poly drawing                      (approx_ c 0.03)                      (which-color c) LINE_AA 1))) The shapes have been greatly simplified, and the number of sides has quite diminished: the shapes are now easier to identify (Figure [3-79](#Fig79)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig79_HTML.jpg](Images/459821_1_En_3_Fig79_HTML.jpg) Figure 3-79

具有简单形状的艺术

## 3.8 移动形状

### 问题

这是基于堆栈溢出时发现的一个问题。

[https://stack overflow . com/questions/32590277/move-area-of-a-image-using-opencv](https://stackoverflow.com/questions/32590277/move-area-of-an-image-to-the-center-using-opencv)

问题是“将图像区域移动到中心”，基本图片如图 [3-80](#Fig80) 所示。

The goal is to move the yellow shape and the black mark inside to the center of the mat.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig80_HTML.jpg](Images/459821_1_En_3_Fig80_HTML.jpg) Figure 3-80

移动形状

### 解决办法

我非常喜欢这个食谱，因为它引入了许多折纸功能，共同致力于一个目标，这也是本章的主题。

The plan to achieve our goal is as follows:

*   首先，给原图加边框，看边界

*   切换到 HSV 颜色空间

*   通过只选择黄色范围内的颜色来创建蒙版

*   从前一个蒙版的边界矩形在原始图片中创建一个 submat

*   创建与原始大小相同的目标结果材质

*   在目标 mat 中创建一个 submat 来放置内容。该子矩阵必须具有相同的大小，并且它将位于中心。

*   将目标垫的其余部分设置为任意颜色…

*   我们完了！

让我们开始吧。

### 它是如何工作的

好的，所以第一步是突出垫子的边界，因为我们不能真正看到它延伸到哪里。

我们将开始加载图片，同时添加边框。

(def img   (-> "resources/morph/cjy6M.jpg"       (imread IMREAD_REDUCED_COLOR_2)       (copy-make-border! 1 1 1 1 BORDER_CONSTANT (->scalar "#aabbcc")))) Bordered input with the rounded yellow mark is now shown in Figure [3-81](#Fig81).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig81_HTML.jpg](Images/459821_1_En_3_Fig81_HTML.jpg) Figure 3-81

黄色标记和边框

然后，我们切换到 hsv 颜色空间，并在黄色标记上创建一个遮罩，这就是折纸管道使一个接一个地传递函数变得容易得多的地方。

(def mask-on-yellow   (->     img     (clone)     (cvt-color! COLOR_BGR2HSV)     (in-range! (new-scalar 20 100 100) (new-scalar 30 255 255)))) Our yellow mask is ready (Figure [3-82](#Fig82)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig82_HTML.jpg](Images/459821_1_En_3_Fig82_HTML.jpg) Figure 3-82

黄色标记上的遮罩

下一步是在新创建的遮罩中找到轮廓。请注意 RETR _ 外部的用法，这意味着我们只对外部轮廓感兴趣，因此黄色标记内的线将不包括在返回的轮廓列表中。

(def contours (new-arraylist)) (find-contours mask-on-yellow contours (new-mat) RETR_EXTERNAL CHAIN_APPROX_SIMPLE)

现在让我们创建一个项目 mat，原始图片的子 mat，其中定义它的矩形是由轮廓的边界矩形构成的。

(def background-color  (->scalar "#000000")) ; mask type CV_8UC1 is important !! (def mask (new-mat (rows img) (cols img) CV_8UC1 background-color)) (def box   (bounding-rect (first contours))) (def item   (submat img box)) The item submat is shown in Figure [3-83](#Fig83).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig83_HTML.jpg](Images/459821_1_En_3_Fig83_HTML.jpg) Figure 3-83

由轮廓的边界矩形组成的 Submat

我们现在创建一个全新的 mat，与 submat 项大小相同，并复制到分段项的内容中。背景颜色必须与结果 mat 的背景颜色相同。

(def segmented-item   (new-mat (rows item) (cols item) CV_8UC3 background-color)) (copy-to item segmented-item (submat mask box) ) The newly computed segmented item is shown in Figure [3-84](#Fig84).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig84_HTML.jpg](Images/459821_1_En_3_Fig84_HTML.jpg) Figure 3-84

分段项目

现在让我们找到将作为复制目标的 rect 的位置。我们希望该项目被移到中心，rect 应该与原来的小盒垫大小相同。

(def center   (new-point (/ (.cols img ) 2 ) (/ (.rows img) 2))) (def center-box   (new-rect     (- (.-x center ) (/ (.-width box) 2))     (- (.-y center ) (/ (.-height box) 2))     (.-width box)     (.-height box)))

好了，一切就绪；现在，我们创建结果 mat，并通过 submat 在前面计算的中心位置复制分段项的内容。

(def result (new-mat (rows img) (cols img) CV_8UC3 background-color)) (def final (submat result center-box)) (copy-to segmented-item final (new-mat))

仅此而已。

The yellow shape has been moved to the center of a new mat. We made sure the white color of the original mat was not copied over, by specifically using a black background for the final result mat (Figure [3-85](#Fig85)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig85_HTML.jpg](Images/459821_1_En_3_Fig85_HTML.jpg) Figure 3-85

获胜

## 3.9 看树

### 问题

这是另一个基于堆栈溢出问题的方法。这一次的兴趣是集中在一个树木种植园，在数树木之前，能够在航拍照片中突出显示它们。

参考问题在这里:

[https://stack overflow . com/questions/31310307/best-way-to-segment-a-tree-in-plantation-air-image-using-opencv](https://stackoverflow.com/questions/31310307/best-way-to-segment-a-tree-in-plantation-aerial-image-using-opencv)

### 解决办法

像往常一样，通过调用范围内的来识别树。但是结果，正如我们将看到的，仍然是相互关联的，这使得实际计数变得非常困难。

我们就来介绍一下**形态学的用法——ex！**来来回回地腐蚀所创建的掩模，从而形成更好的预处理垫，为计数做好准备。

### 它是如何工作的

We will use a picture of a hazy morning forest to work on (Figure [3-86](#Fig86)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig86_HTML.jpg](Images/459821_1_En_3_Fig86_HTML.jpg) Figure 3-86

朦胧的树木

最终，你会想要数一数这些树，但是现在甚至很难用肉眼看到它们。(周围有机器人吗？)

让我们从在绿色的树木上创建一个遮罩开始。

(def in-range-pict   (-> trees       clone       (in-range! (new-scalar 100 80 100) (new-scalar 120 255 255)) (bitwise-not!))) We get a mask of dots … as shown in Figure [3-87](#Fig87).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig87_HTML.jpg](Images/459821_1_En_3_Fig87_HTML.jpg) Figure 3-87

白纸黑字

这个食谱的诀窍就在这里。我们将在图片范围内的 mat 上应用 MORPH_ERODE，然后是 MORPH_OPEN。这将有清理森林的效果，并给每棵树自己的空间。

变形是通过准备一个 mat 来传递一个由小椭圆创建的内核矩阵作为参数来完成的。

(def elem   (get-structuring-element MORPH_ELLIPSE (new-size 3 3)))

如果在 elem 上调用 **dump** ，会发现它的内部表示。

[0 1 0] [1 1 1] [0 1 0]

然后我们使用这个内核矩阵，把它传递给 **morpholy-ex！**。

(morphology-ex! in-range-pict MORPH_ERODE elem (new-point -1 -1) 1) (morphology-ex! in-range-pict MORPH_OPEN elem) This has the desired effect of reducing the size of each tree dot, thus reducing the overlap between the trees (Figure [3-88](#Fig88)).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig88_HTML.jpg](Images/459821_1_En_3_Fig88_HTML.jpg) Figure 3-88

变形后树不重叠

最后，我们只需在原始垫子上应用简单的颜色来突出人眼看到的树的位置。(周围还是没有机器人？)

(def mask   (->     in-range-pict     clone     (in-range! (new-scalar 0 255 255) (new-scalar 0 0 0)))) (def target   (new-mat (.size trees) CV_8UC3)) (set-to target rgb/greenyellow) (copy-to original target mask)

这在视频流中实时进行是很棒的。

你也已经知道接下来等待你的是什么练习。通过快速调用查找轮廓来计算森林中的树木数量…

这当然是留给读者的自由练习！

## 3.10 检测模糊

### 问题

您有大量的图片要分类，并且您希望有一个自动化的过程来丢弃那些模糊的图片。

### 解决办法

该解决方案的灵感来自于 pyimagesearch 网站条目[http://pyimagesearch . com/2015/09/07/blur-detection-with-opencv/](http://pyimagesearch.com/2015/09/07/blur-detection-with-opencv/)，该条目本身指向了 Pech-Pacheco 等人的论文**拉普拉斯**的变体“[硅藻在明场显微镜中的自动聚焦:比较研究](http://optica.csic.es/papers/icpr2k.pdf#_blank)”

它确实突出了将 OpenCV 和这里的 origami 快速转化为有用的东西的酷方法。

基本上，你需要对你的图像的单通道版本应用拉普拉斯过滤器。然后，计算结果与前面结果的偏差，并检查偏差是否低于给定的阈值。

滤镜本身应用了 **filter-2-d！，而方差是用**均值-标准差**计算的。**

### 它是如何工作的

用于滤波器的拉普拉斯矩阵/核将重点放在中心像素上，并减少对左/右上/下像素的强调。

这是我们将要使用的拉普拉斯核。

(def laplacian-kernel   (u/matrix-to-mat   [ [ 0 -1  0]     [-1  4 -1]     [ 0 -1  0]    ]))

让我们用 filter-2d 来应用这个内核吧！，然后调用 mean-std-dev 来计算中值和偏差。

(filter-2-d! img -1 laplacian-kernel) (def std (new-matofdouble)) (def median (new-matofdouble)) (mean-std-dev img median std)

处理图片时，您可以使用 dump 查看平均值的结果，因为它们是矩阵。这显示在下面:

(dump median) ; [19.60282552083333] (dump std) ; [45.26957788759024]

最后，用于比较以检测模糊的值将是偏差的 2 次方。

(Math/pow (first (.get std 0 0)) 2)

然后我们将得到一个与 50 相比较的值。低于 50 表示图像模糊。大于 50 表示图像显示不模糊。

让我们创造一个模糊的图像？由前面所有步骤组成的函数:

(defn std-laplacian [img]   (let [ std (new-matofdouble)]     (filter-2-d! img -1 laplacian-kernel)     (mean-std-dev img (new-matofdouble) std)     (Math/pow (first (.get std 0 0)) 2))) (defn is-image-blurred?[img]   (< (std-laplacian (clone img)) 50))

现在让我们把这个函数应用到一些图片上。

(-> "resources/chapter03/cat-bg-blurred.jpg"     (imread IMREAD_REDUCED_GRAYSCALE_4)     (is-image-blurred?)) And … our first test passes! The cat of Figure [3-89](#Fig89) indeed gives a deserved blurred result.![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig89_HTML.jpg](Images/459821_1_En_3_Fig89_HTML.jpg) Figure 3-89

模糊的猫

And what about one of the most beautiful cat on this planet? That worked too. The cat from Figure [3-90](#Fig90) is recognized as sharp!![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig90_HTML.jpg](Images/459821_1_En_3_Fig90_HTML.jpg) Figure 3-90

敏锐但困倦的猫

现在，也许是时候去整理你所有的海边夏日照片了…

但是，是的，当然，是的，同意，并不是所有模糊的图片都是垃圾。

## 3.11 制作照片拼版

### 问题

大约 20 年前，在一个项目实验室里，我看到了一张巨大的《星球大战》海报，由第一部电影《T2:新的希望》的多个小场景组成。

这张海报很大，从稍远的地方看，它实际上是一张达斯·维德向卢克伸出手的照片。

海报给我留下了很好的印象，我一直想自己做一张。最近，我还知道这种创作的图片有一个名字:照片马赛克。

### 解决办法

这个概念比我最初想的要简单得多。基本上，最难的是下载图片。

你主要需要两个输入，一个最终的图片，和一组用作 subs 的图片。

这项工作包括计算每张图片的 RGB 通道的平均值，并从中创建一个索引。

第一步准备工作完成后，在要复制的图片上创建一个网格，然后对于网格中的每个单元格，计算两个平均值之间的范数:一个来自单元格，一个来自索引的每个文件。

最后，用具有最低平均值的索引中的图片替换大图片的子图片，这意味着该图片在视觉上更接近子图片。

让我们付诸行动吧！

### 它是如何工作的

第一步是编写一个函数来计算一个垫子颜色的平均值。为此，我们再次使用了 **mean-std-dev** ，因为我们只对这个练习的平均值感兴趣，所以这是函数返回的结果。

(defn mean-average-bgr [mat]   (let [_mean (new-matofdouble)]    (-> mat clone    (median-blur! 3)    (mean-std-dev _mean (new-matofdouble)))     _mean))

让我们在任何图片上调用这个，看看会发生什么。

(-> "resources/chapter03/emilie1.jpg"     (imread IMREAD_REDUCED_COLOR_8)     get-averages-bgr-mat     dump)

返回值如下所示。这些值是三个 RGB 通道的平均值。

[123.182] [127.38] [134.128]

让我们稍微回避一下，比较一下三个矩阵的范数:ex1、ex2 和 ex3。看它们的内容，你可以“感觉”到 ex1 和 ex2 比 ex1 和 ex3 更接近。

(def ex1 (u/matrix-to-mat [[0 1 2]])) (def ex2 (u/matrix-to-mat [[0 1 3]])) (def ex3 (u/matrix-to-mat [[0 1 7]])) (norm ex1 ex2) ; 1.0 (norm ex1 ex3) ; 5.0

计算矩阵之间距离的范数函数的输出结果证实了这一点。

这就是我们要用的。首先，我们创建所有可用文件的索引。该索引是通过将每个图像加载为 mat 并计算其均值-平均值-bgr 而创建的图。

  (defn indexing [files for-size]     (zipmap files         (map #(-> % imread (resize! for-size) mean-average-bgr) files)))

该函数的输出是一个映射，其中每个元素是一组键，val 类似 filepath -> mean-average-bgr。

为了找到最接近的图像，现在我们有了一个索引，我们计算所考虑的 mat(或以后的 submat)的范数，以及我们的索引的所有可能的均值-bgr 矩阵。

然后我们进行排序，取尽可能低的值。这就是 find-closest 所做的。

 (defn find-closest [ target indexed ]   (let [mean-bgr-target (get-averages-bgr-mat target)]     (first       (sort-by val <        (apply-to-vals indexed #(norm mean-bgr-target %))))))

apply-to-vals 是一个函数，它接受一个 hashmap 和一个函数，将一个函数应用于 map 中的所有值，其余的保持不变。

(defn apply-to-vals [m f]   (into {} (for [[k v] m] [k (f v)])))

最难的部分完成了；让我们来看看照片拼图算法的实质。

tile 函数是创建输入图片的网格并检索子 mat 的函数，每个子 mat 对应网格的一个 tile。

然后，它逐个遍历所有子 mat，使用相同的函数计算子 mat 的平均颜色平均值，然后使用该平均值和之前创建的索引调用 **find-closest** 。

对 **find-closest** 的调用返回一个文件路径，我们从该路径加载一个 submat，然后替换目标图片中图块的 submat，只需用通常的 **copy-to** 复制加载的 mat。

在这里写的函数 tile 里看到这个。

(defn tile [org indexed ^long grid-x ^long grid-y]   (let[     dst (u/mat-from org)     width (/ (.cols dst) grid-x)     height (/ (.rows dst) grid-y)     total (* grid-x grid-y)     cache (java.util.HashMap.)     ]     (doseq [^long i (range 0 grid-y)]       (doseq [^long j (range 0 grid-x)]       (let [         square          (submat org (new-rect (* j width) (* i height) width height ))         best (first (find-closest square indexed))         img  (get-cache-image cache best  width height)         sub (submat dst (new-rect (* j width) (* i height) width height ))         ]          (copy-to img sub))))     dst))

主入口点是一个名为 **photomosaic** 的函数，它通过预先创建平均值的索引并将其传递给 **tile** 函数来调用 tile 算法。

(defn photomosaic   [images-folder target-image output grid-x grid-y ]   (let [files   (collect-pictures images-folder)         indexed (indexing (collect-pictures images-folder) (new-size grid-x grid-y))         target  (imread target-image )]     (tile target indexed grid-x grid-y))) Whoo-hoo. It’s all there. Creating the photomosaic is now as simple as calling the function of the same name with the proper parameters:

*   jpg 图像的文件夹

*   我们要镶嵌的图片

*   网格的大小

下面是一个简单的例子:

(def lechat   (photomosaic     "resources/cat_photos"     "resources/chapter03/emilie5.jpg"     100 100)) And the first photomosaic ever of Marcel the cat is shown in Figure [3-91](#Fig91).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig91_HTML.jpg](Images/459821_1_En_3_Fig91_HTML.jpg) Figure 3-91

一只熟睡的猫的马赛克

Another photomosaic input/output, this from Kenji’s cat, is in Figure [3-92](#Fig92).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig92_HTML.jpg](Images/459821_1_En_3_Fig92_HTML.jpg) Figure 3-92

古贺圣猫

And, a romantic mosaic in Figure [3-93](#Fig93).![../images/459821_1_En_3_Chapter/459821_1_En_3_Fig93_HTML.jpg](Images/459821_1_En_3_Fig93_HTML.jpg) Figure 3-93

福冈的猫

图片中使用的猫都包括在例子中，没有一只猫受到伤害，所以现在可能是你创造自己的令人敬畏的马赛克的时候了…享受吧！