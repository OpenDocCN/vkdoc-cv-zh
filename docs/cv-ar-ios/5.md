# 五、自定义对象跟踪

在这一章中，我们将介绍如何通过测量背景场景的周期平均值，使用缩小的图像细节来实时跟踪运动和静止的物体。

## 概观

在处理剪辑流而不是单一的静态图片时，我们经常在脑海中有一个特定的对象或项目来跟踪整个视野。

计算机视觉中跟踪的基本问题出现在两种类型之一中；你将在许多场景中跟踪先前识别的物体或者跟踪未知的物体，根据它们的运动来识别它们。

此外，在跟踪中还有建模的问题。在最好的情况下，跟踪策略会一帧一帧地向我们发送对象实际位置的杂乱估计(图 5-1 )。建模帮助我们克服这一点。在测量一个被模糊评估的物体的轨迹时，已经有了几种有效的数学方法。这种策略可用于创建对象及其位置的二维或三维表示。

![img/496594_1_En_5_Fig1_HTML.jpg](img/496594_1_En_5_Fig1_HTML.jpg)

图 5-1

目标跟踪

## 实时目标跟踪

该主题说明了如何使用传统的网络摄像机来实时跟踪移动或固定的对象。当对象开始显示时，一种简单的跟踪方法是将预先指定的背景图片与相同的背景帧进行比较。这种情况发生在固定环境中，在这种环境中，尽管必须跟踪任何前景对象，但您仍可以理解背景图片，例如，室内、楼梯平台、工作场所、市场、车间等。如果一张纸在这种情况下移动或长时间保持不动，人们应该把它当作已经是一种情况的一部分，并把图片叠加到背景上，以防止额外的检测。如果背景对象被场景消除，同样适用。缺乏照明和需要调整凸轮位置都是这种方法的缺点。在这种情况下，您必须再次测量最新的背景。另一种选择是利用边缘算子来减少照明的调整。如果你想描述物体的身体而不仅仅是轮廓，你必须写一些额外的代码。

### 背景

640 × 480 像素的传统网络摄像头分辨率已经过时。如果您计划跟踪非常小的项目，您可以将其缩小大约三倍，以消除失真并大大提高处理器速度，而不会失去关键的跟踪能力。缩减步骤允许在对象跟踪中实现很高的处理速度。当没有物体时，它在 2 GHz 单核上以每秒 100 帧的速度运行，当有物体时，它以每秒 30 到 90 帧的速度运行。对象越大，测量斑点的每个像素需要的时间就越长。除了 ImageBlobs 类，本章和代码都依赖于以前的提交。

### 利用代码

通过设置摄像机和在视频预览中定义的帧捕获级别，以及在缓冲模式下使用 SampleGrabber 将帧捕获到内存中，开始视频捕获。首先，背景测量方法选择一个背景单选按钮。当您选择“启动跟踪”单选按钮框开始对象跟踪时，每一个记录的帧都应该组合在一起，还有一个平均背景帧，它将被计算并存储到一个名为 background 的 JPEG 文件中。我建议你把相机对准一个你认为能看到运动的方向。在处理相机失真或场景中出现的一些随机移动物体时，在很短的时间内测量背景。它们将通过平均背景计算被有效地消除。启动一个物体到你想要追踪的场景中，或者等待直到它们出现，除非它们是活动的。

### 图书馆

推荐对背景帧进行均值估计，因为它有助于提取出每个失真或小运动。

![img/496594_1_En_5_Figa_HTML.jpg](img/496594_1_En_5_Figa_HTML.jpg)

以下类已添加到库中:

![img/496594_1_En_5_Figb_HTML.jpg](img/496594_1_En_5_Figb_HTML.jpg)

在整篇人脸检测文章中，不是采用连续帧之间的差异，而是运动检测器内部的修改使我们能够调整背景帧，其中将对任何新的图片帧执行对比度。ImageResize 对象用于显示背景帧和最新的图像帧。首先，设置视频帧的大小和长度，包括 MotionDetector 对象的缩小因子:

![img/496594_1_En_5_Figc_HTML.jpg](img/496594_1_En_5_Figc_HTML.jpg)

利用 zoom = 0.125f 将图片缩小三倍。如果已经完成了背景计算方法，调用 set background()函数:

![img/496594_1_En_5_Figd_HTML.jpg](img/496594_1_En_5_Figd_HTML.jpg)

我们现在可以利用 detect()函数来计算与前景对象相对应的像素。

![img/496594_1_En_5_Fige_HTML.jpg](img/496594_1_En_5_Fige_HTML.jpg)

您可以选择比较 RGB 值或灰色图片信息。当把物体转换成灰度值时，我们认为这对于相似的阴影是不可靠的。腐蚀和膨胀操作可用于覆盖对象斑点内的一些孔，这可能是因为背景和对象内的相同像素阴影而发生的，以及消除来自非常小的运动或非常薄的对象的噪声。从 ImageBlobs 对象，返回向量已被用于 blob 移除。使用一个类，你必须了解以下特性。

![img/496594_1_En_5_Figf_HTML.jpg](img/496594_1_En_5_Figf_HTML.jpg)

首先，将对象的大小设置为缩小的图片尺寸。

![img/496594_1_En_5_Figg_HTML.jpg](img/496594_1_En_5_Figg_HTML.jpg)

之后，您可以根据通过函数的 MotionDetector:: Detect()调用检索到的图片，开始测量 blob 到 find_blobs()。一个特征着眼于上下相邻的非零图片矢量分量，创建一个斑点。然后将当前发现的斑点数值分配给每个分量。例如，10×10 的矢量被用于图像矢量。

![img/496594_1_En_5_Figi_HTML.jpg](img/496594_1_En_5_Figi_HTML.jpg)

![img/496594_1_En_5_Figh_HTML.jpg](img/496594_1_En_5_Figh_HTML.jpg)

您可以利用![img/496594_1_En_5_Figj_HTML.jpg](img/496594_1_En_5_Figj_HTML.jpg)通过检测来排除较小的斑点(例如，![img/496594_1_En_5_Figk_HTML.jpg](img/496594_1_En_5_Figk_HTML.jpg)将使第三个斑点不被检测到)。

我们可以利用以下方法来获得所发现的斑点的特征:

![img/496594_1_En_5_Figl_HTML.jpg](img/496594_1_En_5_Figl_HTML.jpg)

下面是一个 Blob 结构:

![img/496594_1_En_5_Figm_HTML.jpg](img/496594_1_En_5_Figm_HTML.jpg)

因此，elements number 是存储在元素结构的组件数组中的整个 blob 中的元素的数量。

![img/496594_1_En_5_Fign_HTML.jpg](img/496594_1_En_5_Fign_HTML.jpg)

一条线实际上是图像向量中的分量坐标，并且邻居包括其紧邻的相邻元素。

![img/496594_1_En_5_Figo_HTML.jpg](img/496594_1_En_5_Figo_HTML.jpg)

调用 find blobs()时，我们可以使用 find bounding boxes()在 Blobs::bounding box 屏幕的 RECT 布局中包含的每个 blob 中测量一个边界框。在再次调用 find blobss()之前，必须使用 delete blobs()删除带有图片 blob 对象的 find blob。

find_blob()函数如下所示:

![img/496594_1_En_5_Figp_HTML.jpg](img/496594_1_En_5_Figp_HTML.jpg)

在这里，我们将找到第一个非零条目:

![img/496594_1_En_5_Figq_HTML.jpg](img/496594_1_En_5_Figq_HTML.jpg)

现在我们将在给定的代码中找到 blob。

add * neighbor()过程向上、向下、向左或向右寻找与当前斑点内的第 I 个分量相同的图像分量，然后将其附加到斑点分量阵列:

![img/496594_1_En_5_Figr_HTML.jpg](img/496594_1_En_5_Figr_HTML.jpg)

Is_element_present()和 has _ neighbour()决定，除非这个相同的最新组件已经存在于 blob 内部:

![img/496594_1_En_5_Figs_HTML.jpg](img/496594_1_En_5_Figs_HTML.jpg)

### 结论

我选择了一个固定的背景(图 5-2 )并使用我面前的物品进行了一些物体跟踪测试。我使用的背景如下所示。这在很长一段时间内是平均的。

![img/496594_1_En_5_Fig2_HTML.jpg](img/496594_1_En_5_Fig2_HTML.jpg)

图 5-2

背景

以每秒 66.67 帧的速度，跟踪了两个项目(显示器清洁器和移动设备)(图 5-3 )。

![img/496594_1_En_5_Fig3_HTML.jpg](img/496594_1_En_5_Fig3_HTML.jpg)

图 5-3

视频中的目标跟踪

以每秒 71.43 帧的速度，跟踪到一个移动能量连接器(图 5-4 )。由于脐带看起来很细，腐蚀和扩张技术人员没有观察到它。

![img/496594_1_En_5_Fig4_HTML.jpg](img/496594_1_En_5_Fig4_HTML.jpg)

图 5-4

视频中的目标跟踪

以下为几笔以及锁:每秒 90.91 帧(图 5-5 )。

![img/496594_1_En_5_Fig5_HTML.jpg](img/496594_1_En_5_Fig5_HTML.jpg)

图 5-5

跟踪不同的对象

在相当复杂的情况下，以每秒 29.41 帧的速度观察到三个不同的项目(图 5-6 )。

![img/496594_1_En_5_Fig6_HTML.jpg](img/496594_1_En_5_Fig6_HTML.jpg)

图 5-6

跟踪不同的对象

在 55.56 fps 时，跟踪到一个吉米·亨德里克斯和一个 9v 电源(图 5-7 )。

![img/496594_1_En_5_Fig7_HTML.jpg](img/496594_1_En_5_Fig7_HTML.jpg)

图 5-7

跟踪不同的对象

其他背景配置如下(图 5-8 ):

![img/496594_1_En_5_Fig8_HTML.jpg](img/496594_1_En_5_Fig8_HTML.jpg)

图 5-8

另一个复杂的背景

在 90.91fps 时，观察到许多 9v 电池在地毯上滚动(图 5-9 )。由于组件数量的限制，电池未被观察到。

![img/496594_1_En_5_Fig9_HTML.jpg](img/496594_1_En_5_Fig9_HTML.jpg)

图 5-9

另一个复杂的背景

在每秒 90.91 帧的时候，观察到了一个电池连接器，LCD-TFT 滤镜，9v 电池(图 5-10 )。一个微小的黑洞又一次没有被发现，这次是因为腐蚀和膨胀技术人员。

![img/496594_1_En_5_Fig10_HTML.jpg](img/496594_1_En_5_Fig10_HTML.jpg)

图 5-10

另一个复杂的背景

然后在 83.33 fps 之后，观察到蜡烛和手机(图 5-11 )。

![img/496594_1_En_5_Fig11_HTML.jpg](img/496594_1_En_5_Fig11_HTML.jpg)

图 5-11

另一个复杂的背景

当你观察一个更大的实体时，测量一个 blobs 的组件需要更长的时间。它也不能处理白色背景墙和桌子上物体的阴影。另一方面，高度突出的反射将被跟踪为与项目相关。

### 关注点

人们可以改进跟踪物体边界框位置的算法。如果某个区域在设定的持续时间内是固定的，则可以在背景场景照片中插入一个区域，从而将一个对象集成到场景中。(例如，很少有对象移动到某个场景，但保持不变。)

### 定制条形码生成器/阅读器

#### 利用 C++，建立和读取条形码

在本章中，我们将向您展示如何用 C++编程创建条形码。您还将发现在 C++程序中构建条形码阅读器或扫描仪的方法(图 5-12 )。

![img/496594_1_En_5_Fig12_HTML.jpg](img/496594_1_En_5_Fig12_HTML.jpg)

图 5-12

定制条形码阅读器

信息以机器可以使用条形码读取的格式直观呈现。创新已被证明在各种各样的应用中是有益的，包括商店和市场中的自动检查系统。条形码现在可以用在大多数商品上。条形码越来越成功，导致了跨越几个领域的新应用。几年前，Aspose 认识到条形码的重要性，为不同的渠道推出了条形码生成器和阅读器 API。本章的目的是演示如何在 C++程序中使用条形码生成器和阅读器自动生成和解释条形码。

#### 用于在 C++中生成和读取条形码的 API

假设，C++条形码确实是一个功能性 C++ API，允许用户构建和读取各种 1D 和 2D 条形码。它允许您通过条形码制作、配置和发送更高质量的图片。

以下是适用的条形码符号列表。用 C++编写的条形码将生成:

![img/496594_1_En_5_Figv_HTML.jpg](img/496594_1_En_5_Figv_HTML.jpg)

![img/496594_1_En_5_Figu_HTML.jpg](img/496594_1_En_5_Figu_HTML.jpg)

![img/496594_1_En_5_Figt_HTML.jpg](img/496594_1_En_5_Figt_HTML.jpg)

#### 使用 C++生成条形码

**利用 Aspose 构建条形码:**只需几行代码，就可以创建一个条形码。执行该程序的措施包括:

*   创建条形码生成器类的对象。

*   用条形码的编码形式和文本启动一个对象。

*   使用条形码生成器->保存(System::String)过程，构建条形码。

下面的代码演示说明了如何在 C++中生成条形码:

![img/496594_1_En_5_Figw_HTML.jpg](img/496594_1_En_5_Figw_HTML.jpg)

我们使用之前的代码生成的条形码如下所示(图 5-13 ):

![img/496594_1_En_5_Fig13_HTML.jpg](img/496594_1_En_5_Fig13_HTML.jpg)

图 5-13

定制条形码阅读器

#### 利用 C++，产生一个 2D 条形码(QR 或其他)

我们在前面的实例中生成了一维条形码。我们来做一个二维条码，类似于二维码。制作 QR 条形码的步骤如下:

*   创建条形码生成器类的对象。

*   Encode Types::用于配置对象。设置二维码的文本。

*   使用条形码生成器->保存(System::String)过程，创建条形码图片。

下面的代码演示说明了如何用 C++创建 QR 条形码:

![img/496594_1_En_5_Figx_HTML.jpg](img/496594_1_En_5_Figx_HTML.jpg)

用这个码，二维码确实会产生。

#### 使用 C++，创建和定制条形码

您也可以调整条形码的显示。例如，您可以更改前景色、背景色、比例、边界类型和其他选项。用 Aspose 定制条形码的方法。下面列出了用 C++编写的条形码。

![img/496594_1_En_5_Figy_HTML.jpg](img/496594_1_En_5_Figy_HTML.jpg)

*   创建条形码生成器类的对象。

*   条形码生成器->获取参数()方法用于达到条形码规格。

*   定义你喜欢的规格。

*   制作条形码并保存为照片。

以下编码演示说明了如何在 C++中创建个性化条形码:

![img/496594_1_En_5_Figz_HTML.jpg](img/496594_1_En_5_Figz_HTML.jpg)

我们创建的可定制的 Aztec 条形码如下所示(图 5-14 ):

![img/496594_1_En_5_Fig14_HTML.jpg](img/496594_1_En_5_Fig14_HTML.jpg)

图 5-14

可定制的阿兹特克条形码

#### 利用 C++，创建带字幕的条形码

标题可以出现在条形码的下方或上方。条形码图片中标题的内容和外观也可以自定义。下面的代码示例说明了如何在 C++中构建带标题的条形码:

![img/496594_1_En_5_Fig15_HTML.jpg](img/496594_1_En_5_Fig15_HTML.jpg)

图 5-15

这里可以看到包含上下标题的条形码

![img/496594_1_En_5_Figaa_HTML.jpg](img/496594_1_En_5_Figaa_HTML.jpg)

#### 利用 C++，扫描和读取条形码

让我们看看如何使用 Aspose。用于 C++扫描和读取条形码的条形码。使用该功能的步骤如下:

*   从条形码阅读器类创建一个实体。

*   制作一个条形码阅读器示例，包括条形码及其符号的图片文件。

*   要获取条形码的文本或形式，请使用条形码阅读器->Read()工具。

下面的编程示例演示了如何在 C++中搜索和解释条形码:

![img/496594_1_En_5_Figab_HTML.jpg](img/496594_1_En_5_Figab_HTML.jpg)

#### C++用于读取具有几种符号体系的条形码

在大多数情况下，一张图片只包含一个条形码符号。即便如此，在某些情况下，一幅图片可以包括在相对相似的时期内来自若干符号体系的条形码。在这种情况下，您应该有一个条形码符号集，以便进行扫描和读取。下面的程序示例演示了如何使用 C++扫描带有多种条形码符号的图片:

![img/496594_1_En_5_Figac_HTML.jpg](img/496594_1_En_5_Figac_HTML.jpg)

## 摘要

在本章中，您学习了如何使用 C++构建各种符号体系的条形码。通过 C++代码示例，讲述了条形码的扫描和读取。这些文档将帮助你理解所有关于 API 的内容。